// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sp2p_protocol.proto

#ifndef PROTOBUF_sp2p_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_sp2p_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

class ClientMessage;
class ClientMessage_Register;
class ClientMessage_Unregister;
class ClientMessage_Login;
class ClientMessage_Logout;
class ClientMessage_ListNetworks;
class ClientMessage_ListMyNetworks;
class ClientMessage_ListServers;
class ClientMessage_CreateNetwork;
class ClientMessage_DeleteNetwork;
class ClientMessage_InviteUser;
class ClientMessage_RemoveUser;
class ClientMessage_UserInfo;
class ClientMessage_UpdateServer;
class ClientMessage_StopServer;
class ClientMessage_SignKey;
class NodeMessage;
class NodeMessage_Register;
class NodeMessage_Login;
class NodeMessage_ListNetworks;
class NodeMessage_ListNetworks_Network;
class NodeMessage_ListMyNetworks;
class NodeMessage_ListServers;
class NodeMessage_ListServers_Server;
class NodeMessage_UserInfo;
class NodeMessage_UpdateServer;
class NodeMessage_SignKey;

enum ClientMessage_CreateNetwork_AccessRights {
  ClientMessage_CreateNetwork_AccessRights_PUBLIC = 1,
  ClientMessage_CreateNetwork_AccessRights_PRIVATE = 2
};
bool ClientMessage_CreateNetwork_AccessRights_IsValid(int value);
const ClientMessage_CreateNetwork_AccessRights ClientMessage_CreateNetwork_AccessRights_AccessRights_MIN = ClientMessage_CreateNetwork_AccessRights_PUBLIC;
const ClientMessage_CreateNetwork_AccessRights ClientMessage_CreateNetwork_AccessRights_AccessRights_MAX = ClientMessage_CreateNetwork_AccessRights_PRIVATE;
const int ClientMessage_CreateNetwork_AccessRights_AccessRights_ARRAYSIZE = ClientMessage_CreateNetwork_AccessRights_AccessRights_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_CreateNetwork_AccessRights_descriptor();
inline const ::std::string& ClientMessage_CreateNetwork_AccessRights_Name(ClientMessage_CreateNetwork_AccessRights value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_CreateNetwork_AccessRights_descriptor(), value);
}
inline bool ClientMessage_CreateNetwork_AccessRights_Parse(
    const ::std::string& name, ClientMessage_CreateNetwork_AccessRights* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_CreateNetwork_AccessRights>(
    ClientMessage_CreateNetwork_AccessRights_descriptor(), name, value);
}
enum ClientMessage_CreateNetwork_Visiblity {
  ClientMessage_CreateNetwork_Visiblity_LISTED = 3,
  ClientMessage_CreateNetwork_Visiblity_UNLISTED = 4
};
bool ClientMessage_CreateNetwork_Visiblity_IsValid(int value);
const ClientMessage_CreateNetwork_Visiblity ClientMessage_CreateNetwork_Visiblity_Visiblity_MIN = ClientMessage_CreateNetwork_Visiblity_LISTED;
const ClientMessage_CreateNetwork_Visiblity ClientMessage_CreateNetwork_Visiblity_Visiblity_MAX = ClientMessage_CreateNetwork_Visiblity_UNLISTED;
const int ClientMessage_CreateNetwork_Visiblity_Visiblity_ARRAYSIZE = ClientMessage_CreateNetwork_Visiblity_Visiblity_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_CreateNetwork_Visiblity_descriptor();
inline const ::std::string& ClientMessage_CreateNetwork_Visiblity_Name(ClientMessage_CreateNetwork_Visiblity value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_CreateNetwork_Visiblity_descriptor(), value);
}
inline bool ClientMessage_CreateNetwork_Visiblity_Parse(
    const ::std::string& name, ClientMessage_CreateNetwork_Visiblity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_CreateNetwork_Visiblity>(
    ClientMessage_CreateNetwork_Visiblity_descriptor(), name, value);
}
enum ClientMessage_CreateNetwork_ParticipationRights {
  ClientMessage_CreateNetwork_ParticipationRights_CLIENT_ONLY = 5,
  ClientMessage_CreateNetwork_ParticipationRights_CLIENT_SERVER = 6
};
bool ClientMessage_CreateNetwork_ParticipationRights_IsValid(int value);
const ClientMessage_CreateNetwork_ParticipationRights ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_MIN = ClientMessage_CreateNetwork_ParticipationRights_CLIENT_ONLY;
const ClientMessage_CreateNetwork_ParticipationRights ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_MAX = ClientMessage_CreateNetwork_ParticipationRights_CLIENT_SERVER;
const int ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_ARRAYSIZE = ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_CreateNetwork_ParticipationRights_descriptor();
inline const ::std::string& ClientMessage_CreateNetwork_ParticipationRights_Name(ClientMessage_CreateNetwork_ParticipationRights value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_CreateNetwork_ParticipationRights_descriptor(), value);
}
inline bool ClientMessage_CreateNetwork_ParticipationRights_Parse(
    const ::std::string& name, ClientMessage_CreateNetwork_ParticipationRights* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_CreateNetwork_ParticipationRights>(
    ClientMessage_CreateNetwork_ParticipationRights_descriptor(), name, value);
}
enum ClientMessage_RequestType {
  ClientMessage_RequestType_REGISTER = 0,
  ClientMessage_RequestType_UNREGISTER = 1,
  ClientMessage_RequestType_LOGIN = 2,
  ClientMessage_RequestType_LOGOUT = 3,
  ClientMessage_RequestType_LIST_NETWORKS = 4,
  ClientMessage_RequestType_LIST_MY_NETWORKS = 5,
  ClientMessage_RequestType_LIST_SERVERS = 6,
  ClientMessage_RequestType_CREATE_NETWORK = 7,
  ClientMessage_RequestType_DELETE_NETWORK = 8,
  ClientMessage_RequestType_INVITE_USER = 9,
  ClientMessage_RequestType_REMOVE_USER = 10,
  ClientMessage_RequestType_USER_INFO = 11,
  ClientMessage_RequestType_UPDATE_SERVER = 12,
  ClientMessage_RequestType_STOP_SERVER = 13,
  ClientMessage_RequestType_SIGN_KEY = 14
};
bool ClientMessage_RequestType_IsValid(int value);
const ClientMessage_RequestType ClientMessage_RequestType_RequestType_MIN = ClientMessage_RequestType_REGISTER;
const ClientMessage_RequestType ClientMessage_RequestType_RequestType_MAX = ClientMessage_RequestType_SIGN_KEY;
const int ClientMessage_RequestType_RequestType_ARRAYSIZE = ClientMessage_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_RequestType_descriptor();
inline const ::std::string& ClientMessage_RequestType_Name(ClientMessage_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_RequestType_descriptor(), value);
}
inline bool ClientMessage_RequestType_Parse(
    const ::std::string& name, ClientMessage_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_RequestType>(
    ClientMessage_RequestType_descriptor(), name, value);
}
enum NodeMessage_ResponseType {
  NodeMessage_ResponseType_OK = 200,
  NodeMessage_ResponseType_INTERNAL_SERVER_ERROR = 400,
  NodeMessage_ResponseType_BAD_REQUEST = 500,
  NodeMessage_ResponseType_NO_PRIVILAGES = 501,
  NodeMessage_ResponseType_NOT_LOGGED = 502,
  NodeMessage_ResponseType_BAD_CREDENTIALS = 503,
  NodeMessage_ResponseType_NO_SUCH_USER = 504,
  NodeMessage_ResponseType_NO_SUCH_NETWORK = 505,
  NodeMessage_ResponseType_BAD_DATA = 506
};
bool NodeMessage_ResponseType_IsValid(int value);
const NodeMessage_ResponseType NodeMessage_ResponseType_ResponseType_MIN = NodeMessage_ResponseType_OK;
const NodeMessage_ResponseType NodeMessage_ResponseType_ResponseType_MAX = NodeMessage_ResponseType_BAD_DATA;
const int NodeMessage_ResponseType_ResponseType_ARRAYSIZE = NodeMessage_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeMessage_ResponseType_descriptor();
inline const ::std::string& NodeMessage_ResponseType_Name(NodeMessage_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeMessage_ResponseType_descriptor(), value);
}
inline bool NodeMessage_ResponseType_Parse(
    const ::std::string& name, NodeMessage_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeMessage_ResponseType>(
    NodeMessage_ResponseType_descriptor(), name, value);
}
// ===================================================================

class ClientMessage_Register : public ::google::protobuf::Message {
 public:
  ClientMessage_Register();
  virtual ~ClientMessage_Register();

  ClientMessage_Register(const ClientMessage_Register& from);

  inline ClientMessage_Register& operator=(const ClientMessage_Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_Register& default_instance();

  void Swap(ClientMessage_Register* other);

  // implements Message ----------------------------------------------

  ClientMessage_Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_Register& from);
  void MergeFrom(const ClientMessage_Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.Register)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_public_key();
  inline void clear_has_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* public_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_Register* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_Unregister : public ::google::protobuf::Message {
 public:
  ClientMessage_Unregister();
  virtual ~ClientMessage_Unregister();

  ClientMessage_Unregister(const ClientMessage_Unregister& from);

  inline ClientMessage_Unregister& operator=(const ClientMessage_Unregister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_Unregister& default_instance();

  void Swap(ClientMessage_Unregister* other);

  // implements Message ----------------------------------------------

  ClientMessage_Unregister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_Unregister& from);
  void MergeFrom(const ClientMessage_Unregister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.Unregister)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_Unregister* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_Login : public ::google::protobuf::Message {
 public:
  ClientMessage_Login();
  virtual ~ClientMessage_Login();

  ClientMessage_Login(const ClientMessage_Login& from);

  inline ClientMessage_Login& operator=(const ClientMessage_Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_Login& default_instance();

  void Swap(ClientMessage_Login* other);

  // implements Message ----------------------------------------------

  ClientMessage_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_Login& from);
  void MergeFrom(const ClientMessage_Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.Login)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_Login* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_Logout : public ::google::protobuf::Message {
 public:
  ClientMessage_Logout();
  virtual ~ClientMessage_Logout();

  ClientMessage_Logout(const ClientMessage_Logout& from);

  inline ClientMessage_Logout& operator=(const ClientMessage_Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_Logout& default_instance();

  void Swap(ClientMessage_Logout* other);

  // implements Message ----------------------------------------------

  ClientMessage_Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_Logout& from);
  void MergeFrom(const ClientMessage_Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.Logout)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_Logout* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_ListNetworks : public ::google::protobuf::Message {
 public:
  ClientMessage_ListNetworks();
  virtual ~ClientMessage_ListNetworks();

  ClientMessage_ListNetworks(const ClientMessage_ListNetworks& from);

  inline ClientMessage_ListNetworks& operator=(const ClientMessage_ListNetworks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_ListNetworks& default_instance();

  void Swap(ClientMessage_ListNetworks* other);

  // implements Message ----------------------------------------------

  ClientMessage_ListNetworks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_ListNetworks& from);
  void MergeFrom(const ClientMessage_ListNetworks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.ListNetworks)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_ListNetworks* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_ListMyNetworks : public ::google::protobuf::Message {
 public:
  ClientMessage_ListMyNetworks();
  virtual ~ClientMessage_ListMyNetworks();

  ClientMessage_ListMyNetworks(const ClientMessage_ListMyNetworks& from);

  inline ClientMessage_ListMyNetworks& operator=(const ClientMessage_ListMyNetworks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_ListMyNetworks& default_instance();

  void Swap(ClientMessage_ListMyNetworks* other);

  // implements Message ----------------------------------------------

  ClientMessage_ListMyNetworks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_ListMyNetworks& from);
  void MergeFrom(const ClientMessage_ListMyNetworks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.ListMyNetworks)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_ListMyNetworks* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_ListServers : public ::google::protobuf::Message {
 public:
  ClientMessage_ListServers();
  virtual ~ClientMessage_ListServers();

  ClientMessage_ListServers(const ClientMessage_ListServers& from);

  inline ClientMessage_ListServers& operator=(const ClientMessage_ListServers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_ListServers& default_instance();

  void Swap(ClientMessage_ListServers* other);

  // implements Message ----------------------------------------------

  ClientMessage_ListServers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_ListServers& from);
  void MergeFrom(const ClientMessage_ListServers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string network_name = 2;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 2;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.ListServers)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_ListServers* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_CreateNetwork : public ::google::protobuf::Message {
 public:
  ClientMessage_CreateNetwork();
  virtual ~ClientMessage_CreateNetwork();

  ClientMessage_CreateNetwork(const ClientMessage_CreateNetwork& from);

  inline ClientMessage_CreateNetwork& operator=(const ClientMessage_CreateNetwork& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_CreateNetwork& default_instance();

  void Swap(ClientMessage_CreateNetwork* other);

  // implements Message ----------------------------------------------

  ClientMessage_CreateNetwork* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_CreateNetwork& from);
  void MergeFrom(const ClientMessage_CreateNetwork& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientMessage_CreateNetwork_AccessRights AccessRights;
  static const AccessRights PUBLIC = ClientMessage_CreateNetwork_AccessRights_PUBLIC;
  static const AccessRights PRIVATE = ClientMessage_CreateNetwork_AccessRights_PRIVATE;
  static inline bool AccessRights_IsValid(int value) {
    return ClientMessage_CreateNetwork_AccessRights_IsValid(value);
  }
  static const AccessRights AccessRights_MIN =
    ClientMessage_CreateNetwork_AccessRights_AccessRights_MIN;
  static const AccessRights AccessRights_MAX =
    ClientMessage_CreateNetwork_AccessRights_AccessRights_MAX;
  static const int AccessRights_ARRAYSIZE =
    ClientMessage_CreateNetwork_AccessRights_AccessRights_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AccessRights_descriptor() {
    return ClientMessage_CreateNetwork_AccessRights_descriptor();
  }
  static inline const ::std::string& AccessRights_Name(AccessRights value) {
    return ClientMessage_CreateNetwork_AccessRights_Name(value);
  }
  static inline bool AccessRights_Parse(const ::std::string& name,
      AccessRights* value) {
    return ClientMessage_CreateNetwork_AccessRights_Parse(name, value);
  }

  typedef ClientMessage_CreateNetwork_Visiblity Visiblity;
  static const Visiblity LISTED = ClientMessage_CreateNetwork_Visiblity_LISTED;
  static const Visiblity UNLISTED = ClientMessage_CreateNetwork_Visiblity_UNLISTED;
  static inline bool Visiblity_IsValid(int value) {
    return ClientMessage_CreateNetwork_Visiblity_IsValid(value);
  }
  static const Visiblity Visiblity_MIN =
    ClientMessage_CreateNetwork_Visiblity_Visiblity_MIN;
  static const Visiblity Visiblity_MAX =
    ClientMessage_CreateNetwork_Visiblity_Visiblity_MAX;
  static const int Visiblity_ARRAYSIZE =
    ClientMessage_CreateNetwork_Visiblity_Visiblity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Visiblity_descriptor() {
    return ClientMessage_CreateNetwork_Visiblity_descriptor();
  }
  static inline const ::std::string& Visiblity_Name(Visiblity value) {
    return ClientMessage_CreateNetwork_Visiblity_Name(value);
  }
  static inline bool Visiblity_Parse(const ::std::string& name,
      Visiblity* value) {
    return ClientMessage_CreateNetwork_Visiblity_Parse(name, value);
  }

  typedef ClientMessage_CreateNetwork_ParticipationRights ParticipationRights;
  static const ParticipationRights CLIENT_ONLY = ClientMessage_CreateNetwork_ParticipationRights_CLIENT_ONLY;
  static const ParticipationRights CLIENT_SERVER = ClientMessage_CreateNetwork_ParticipationRights_CLIENT_SERVER;
  static inline bool ParticipationRights_IsValid(int value) {
    return ClientMessage_CreateNetwork_ParticipationRights_IsValid(value);
  }
  static const ParticipationRights ParticipationRights_MIN =
    ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_MIN;
  static const ParticipationRights ParticipationRights_MAX =
    ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_MAX;
  static const int ParticipationRights_ARRAYSIZE =
    ClientMessage_CreateNetwork_ParticipationRights_ParticipationRights_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ParticipationRights_descriptor() {
    return ClientMessage_CreateNetwork_ParticipationRights_descriptor();
  }
  static inline const ::std::string& ParticipationRights_Name(ParticipationRights value) {
    return ClientMessage_CreateNetwork_ParticipationRights_Name(value);
  }
  static inline bool ParticipationRights_Parse(const ::std::string& name,
      ParticipationRights* value) {
    return ClientMessage_CreateNetwork_ParticipationRights_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string network_name = 2;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 2;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // required .protocol.ClientMessage.CreateNetwork.AccessRights access_rights = 3;
  inline bool has_access_rights() const;
  inline void clear_access_rights();
  static const int kAccessRightsFieldNumber = 3;
  inline ::protocol::ClientMessage_CreateNetwork_AccessRights access_rights() const;
  inline void set_access_rights(::protocol::ClientMessage_CreateNetwork_AccessRights value);

  // required .protocol.ClientMessage.CreateNetwork.Visiblity visibility = 4;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 4;
  inline ::protocol::ClientMessage_CreateNetwork_Visiblity visibility() const;
  inline void set_visibility(::protocol::ClientMessage_CreateNetwork_Visiblity value);

  // required .protocol.ClientMessage.CreateNetwork.ParticipationRights participation_rights = 5;
  inline bool has_participation_rights() const;
  inline void clear_participation_rights();
  static const int kParticipationRightsFieldNumber = 5;
  inline ::protocol::ClientMessage_CreateNetwork_ParticipationRights participation_rights() const;
  inline void set_participation_rights(::protocol::ClientMessage_CreateNetwork_ParticipationRights value);

  // optional string creator_email = 6;
  inline bool has_creator_email() const;
  inline void clear_creator_email();
  static const int kCreatorEmailFieldNumber = 6;
  inline const ::std::string& creator_email() const;
  inline void set_creator_email(const ::std::string& value);
  inline void set_creator_email(const char* value);
  inline void set_creator_email(const char* value, size_t size);
  inline ::std::string* mutable_creator_email();
  inline ::std::string* release_creator_email();
  inline void set_allocated_creator_email(::std::string* creator_email);

  // optional string protocol_name = 7;
  inline bool has_protocol_name() const;
  inline void clear_protocol_name();
  static const int kProtocolNameFieldNumber = 7;
  inline const ::std::string& protocol_name() const;
  inline void set_protocol_name(const ::std::string& value);
  inline void set_protocol_name(const char* value);
  inline void set_protocol_name(const char* value, size_t size);
  inline ::std::string* mutable_protocol_name();
  inline ::std::string* release_protocol_name();
  inline void set_allocated_protocol_name(::std::string* protocol_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.CreateNetwork)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_network_name();
  inline void clear_has_network_name();
  inline void set_has_access_rights();
  inline void clear_has_access_rights();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_participation_rights();
  inline void clear_has_participation_rights();
  inline void set_has_creator_email();
  inline void clear_has_creator_email();
  inline void set_has_protocol_name();
  inline void clear_has_protocol_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* network_name_;
  int access_rights_;
  int visibility_;
  ::std::string* creator_email_;
  ::std::string* protocol_name_;
  int participation_rights_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_CreateNetwork* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_DeleteNetwork : public ::google::protobuf::Message {
 public:
  ClientMessage_DeleteNetwork();
  virtual ~ClientMessage_DeleteNetwork();

  ClientMessage_DeleteNetwork(const ClientMessage_DeleteNetwork& from);

  inline ClientMessage_DeleteNetwork& operator=(const ClientMessage_DeleteNetwork& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_DeleteNetwork& default_instance();

  void Swap(ClientMessage_DeleteNetwork* other);

  // implements Message ----------------------------------------------

  ClientMessage_DeleteNetwork* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_DeleteNetwork& from);
  void MergeFrom(const ClientMessage_DeleteNetwork& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.DeleteNetwork)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_DeleteNetwork* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_InviteUser : public ::google::protobuf::Message {
 public:
  ClientMessage_InviteUser();
  virtual ~ClientMessage_InviteUser();

  ClientMessage_InviteUser(const ClientMessage_InviteUser& from);

  inline ClientMessage_InviteUser& operator=(const ClientMessage_InviteUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_InviteUser& default_instance();

  void Swap(ClientMessage_InviteUser* other);

  // implements Message ----------------------------------------------

  ClientMessage_InviteUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_InviteUser& from);
  void MergeFrom(const ClientMessage_InviteUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string network_name = 3;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 3;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.InviteUser)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* username_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_InviteUser* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_RemoveUser : public ::google::protobuf::Message {
 public:
  ClientMessage_RemoveUser();
  virtual ~ClientMessage_RemoveUser();

  ClientMessage_RemoveUser(const ClientMessage_RemoveUser& from);

  inline ClientMessage_RemoveUser& operator=(const ClientMessage_RemoveUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_RemoveUser& default_instance();

  void Swap(ClientMessage_RemoveUser* other);

  // implements Message ----------------------------------------------

  ClientMessage_RemoveUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_RemoveUser& from);
  void MergeFrom(const ClientMessage_RemoveUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string network_name = 3;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 3;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.RemoveUser)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* username_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_RemoveUser* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_UserInfo : public ::google::protobuf::Message {
 public:
  ClientMessage_UserInfo();
  virtual ~ClientMessage_UserInfo();

  ClientMessage_UserInfo(const ClientMessage_UserInfo& from);

  inline ClientMessage_UserInfo& operator=(const ClientMessage_UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_UserInfo& default_instance();

  void Swap(ClientMessage_UserInfo* other);

  // implements Message ----------------------------------------------

  ClientMessage_UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_UserInfo& from);
  void MergeFrom(const ClientMessage_UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string network_name = 3;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 3;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.UserInfo)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* username_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_UpdateServer : public ::google::protobuf::Message {
 public:
  ClientMessage_UpdateServer();
  virtual ~ClientMessage_UpdateServer();

  ClientMessage_UpdateServer(const ClientMessage_UpdateServer& from);

  inline ClientMessage_UpdateServer& operator=(const ClientMessage_UpdateServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_UpdateServer& default_instance();

  void Swap(ClientMessage_UpdateServer* other);

  // implements Message ----------------------------------------------

  ClientMessage_UpdateServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_UpdateServer& from);
  void MergeFrom(const ClientMessage_UpdateServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string network_name = 2;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 2;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // required int32 port_number = 3;
  inline bool has_port_number() const;
  inline void clear_port_number();
  static const int kPortNumberFieldNumber = 3;
  inline ::google::protobuf::int32 port_number() const;
  inline void set_port_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.UpdateServer)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_network_name();
  inline void clear_has_network_name();
  inline void set_has_port_number();
  inline void clear_has_port_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* network_name_;
  ::google::protobuf::int32 port_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_UpdateServer* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_StopServer : public ::google::protobuf::Message {
 public:
  ClientMessage_StopServer();
  virtual ~ClientMessage_StopServer();

  ClientMessage_StopServer(const ClientMessage_StopServer& from);

  inline ClientMessage_StopServer& operator=(const ClientMessage_StopServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_StopServer& default_instance();

  void Swap(ClientMessage_StopServer* other);

  // implements Message ----------------------------------------------

  ClientMessage_StopServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_StopServer& from);
  void MergeFrom(const ClientMessage_StopServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string network_name = 2;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 2;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.StopServer)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_StopServer* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage_SignKey : public ::google::protobuf::Message {
 public:
  ClientMessage_SignKey();
  virtual ~ClientMessage_SignKey();

  ClientMessage_SignKey(const ClientMessage_SignKey& from);

  inline ClientMessage_SignKey& operator=(const ClientMessage_SignKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_SignKey& default_instance();

  void Swap(ClientMessage_SignKey* other);

  // implements Message ----------------------------------------------

  ClientMessage_SignKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage_SignKey& from);
  void MergeFrom(const ClientMessage_SignKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // required string public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional string network_name = 3;
  inline bool has_network_name() const;
  inline void clear_network_name();
  static const int kNetworkNameFieldNumber = 3;
  inline const ::std::string& network_name() const;
  inline void set_network_name(const ::std::string& value);
  inline void set_network_name(const char* value);
  inline void set_network_name(const char* value, size_t size);
  inline ::std::string* mutable_network_name();
  inline ::std::string* release_network_name();
  inline void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage.SignKey)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_network_name();
  inline void clear_has_network_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* public_key_;
  ::std::string* network_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage_SignKey* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  void Swap(ClientMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientMessage_Register Register;
  typedef ClientMessage_Unregister Unregister;
  typedef ClientMessage_Login Login;
  typedef ClientMessage_Logout Logout;
  typedef ClientMessage_ListNetworks ListNetworks;
  typedef ClientMessage_ListMyNetworks ListMyNetworks;
  typedef ClientMessage_ListServers ListServers;
  typedef ClientMessage_CreateNetwork CreateNetwork;
  typedef ClientMessage_DeleteNetwork DeleteNetwork;
  typedef ClientMessage_InviteUser InviteUser;
  typedef ClientMessage_RemoveUser RemoveUser;
  typedef ClientMessage_UserInfo UserInfo;
  typedef ClientMessage_UpdateServer UpdateServer;
  typedef ClientMessage_StopServer StopServer;
  typedef ClientMessage_SignKey SignKey;

  typedef ClientMessage_RequestType RequestType;
  static const RequestType REGISTER = ClientMessage_RequestType_REGISTER;
  static const RequestType UNREGISTER = ClientMessage_RequestType_UNREGISTER;
  static const RequestType LOGIN = ClientMessage_RequestType_LOGIN;
  static const RequestType LOGOUT = ClientMessage_RequestType_LOGOUT;
  static const RequestType LIST_NETWORKS = ClientMessage_RequestType_LIST_NETWORKS;
  static const RequestType LIST_MY_NETWORKS = ClientMessage_RequestType_LIST_MY_NETWORKS;
  static const RequestType LIST_SERVERS = ClientMessage_RequestType_LIST_SERVERS;
  static const RequestType CREATE_NETWORK = ClientMessage_RequestType_CREATE_NETWORK;
  static const RequestType DELETE_NETWORK = ClientMessage_RequestType_DELETE_NETWORK;
  static const RequestType INVITE_USER = ClientMessage_RequestType_INVITE_USER;
  static const RequestType REMOVE_USER = ClientMessage_RequestType_REMOVE_USER;
  static const RequestType USER_INFO = ClientMessage_RequestType_USER_INFO;
  static const RequestType UPDATE_SERVER = ClientMessage_RequestType_UPDATE_SERVER;
  static const RequestType STOP_SERVER = ClientMessage_RequestType_STOP_SERVER;
  static const RequestType SIGN_KEY = ClientMessage_RequestType_SIGN_KEY;
  static inline bool RequestType_IsValid(int value) {
    return ClientMessage_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    ClientMessage_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    ClientMessage_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    ClientMessage_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return ClientMessage_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return ClientMessage_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return ClientMessage_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protocol.ClientMessage.RequestType request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline ::protocol::ClientMessage_RequestType request() const;
  inline void set_request(::protocol::ClientMessage_RequestType value);

  // optional .protocol.ClientMessage.Register register_message = 2;
  inline bool has_register_message() const;
  inline void clear_register_message();
  static const int kRegisterMessageFieldNumber = 2;
  inline const ::protocol::ClientMessage_Register& register_message() const;
  inline ::protocol::ClientMessage_Register* mutable_register_message();
  inline ::protocol::ClientMessage_Register* release_register_message();
  inline void set_allocated_register_message(::protocol::ClientMessage_Register* register_message);

  // optional .protocol.ClientMessage.Unregister unregister_message = 3;
  inline bool has_unregister_message() const;
  inline void clear_unregister_message();
  static const int kUnregisterMessageFieldNumber = 3;
  inline const ::protocol::ClientMessage_Unregister& unregister_message() const;
  inline ::protocol::ClientMessage_Unregister* mutable_unregister_message();
  inline ::protocol::ClientMessage_Unregister* release_unregister_message();
  inline void set_allocated_unregister_message(::protocol::ClientMessage_Unregister* unregister_message);

  // optional .protocol.ClientMessage.Login login_message = 4;
  inline bool has_login_message() const;
  inline void clear_login_message();
  static const int kLoginMessageFieldNumber = 4;
  inline const ::protocol::ClientMessage_Login& login_message() const;
  inline ::protocol::ClientMessage_Login* mutable_login_message();
  inline ::protocol::ClientMessage_Login* release_login_message();
  inline void set_allocated_login_message(::protocol::ClientMessage_Login* login_message);

  // optional .protocol.ClientMessage.Logout logout_message = 5;
  inline bool has_logout_message() const;
  inline void clear_logout_message();
  static const int kLogoutMessageFieldNumber = 5;
  inline const ::protocol::ClientMessage_Logout& logout_message() const;
  inline ::protocol::ClientMessage_Logout* mutable_logout_message();
  inline ::protocol::ClientMessage_Logout* release_logout_message();
  inline void set_allocated_logout_message(::protocol::ClientMessage_Logout* logout_message);

  // optional .protocol.ClientMessage.ListNetworks list_networks_message = 6;
  inline bool has_list_networks_message() const;
  inline void clear_list_networks_message();
  static const int kListNetworksMessageFieldNumber = 6;
  inline const ::protocol::ClientMessage_ListNetworks& list_networks_message() const;
  inline ::protocol::ClientMessage_ListNetworks* mutable_list_networks_message();
  inline ::protocol::ClientMessage_ListNetworks* release_list_networks_message();
  inline void set_allocated_list_networks_message(::protocol::ClientMessage_ListNetworks* list_networks_message);

  // optional .protocol.ClientMessage.ListMyNetworks list_my_networks_message = 7;
  inline bool has_list_my_networks_message() const;
  inline void clear_list_my_networks_message();
  static const int kListMyNetworksMessageFieldNumber = 7;
  inline const ::protocol::ClientMessage_ListMyNetworks& list_my_networks_message() const;
  inline ::protocol::ClientMessage_ListMyNetworks* mutable_list_my_networks_message();
  inline ::protocol::ClientMessage_ListMyNetworks* release_list_my_networks_message();
  inline void set_allocated_list_my_networks_message(::protocol::ClientMessage_ListMyNetworks* list_my_networks_message);

  // optional .protocol.ClientMessage.ListServers list_servers_message = 8;
  inline bool has_list_servers_message() const;
  inline void clear_list_servers_message();
  static const int kListServersMessageFieldNumber = 8;
  inline const ::protocol::ClientMessage_ListServers& list_servers_message() const;
  inline ::protocol::ClientMessage_ListServers* mutable_list_servers_message();
  inline ::protocol::ClientMessage_ListServers* release_list_servers_message();
  inline void set_allocated_list_servers_message(::protocol::ClientMessage_ListServers* list_servers_message);

  // optional .protocol.ClientMessage.CreateNetwork create_network_message = 9;
  inline bool has_create_network_message() const;
  inline void clear_create_network_message();
  static const int kCreateNetworkMessageFieldNumber = 9;
  inline const ::protocol::ClientMessage_CreateNetwork& create_network_message() const;
  inline ::protocol::ClientMessage_CreateNetwork* mutable_create_network_message();
  inline ::protocol::ClientMessage_CreateNetwork* release_create_network_message();
  inline void set_allocated_create_network_message(::protocol::ClientMessage_CreateNetwork* create_network_message);

  // optional .protocol.ClientMessage.DeleteNetwork delete_network_message = 10;
  inline bool has_delete_network_message() const;
  inline void clear_delete_network_message();
  static const int kDeleteNetworkMessageFieldNumber = 10;
  inline const ::protocol::ClientMessage_DeleteNetwork& delete_network_message() const;
  inline ::protocol::ClientMessage_DeleteNetwork* mutable_delete_network_message();
  inline ::protocol::ClientMessage_DeleteNetwork* release_delete_network_message();
  inline void set_allocated_delete_network_message(::protocol::ClientMessage_DeleteNetwork* delete_network_message);

  // optional .protocol.ClientMessage.InviteUser invite_user_message = 11;
  inline bool has_invite_user_message() const;
  inline void clear_invite_user_message();
  static const int kInviteUserMessageFieldNumber = 11;
  inline const ::protocol::ClientMessage_InviteUser& invite_user_message() const;
  inline ::protocol::ClientMessage_InviteUser* mutable_invite_user_message();
  inline ::protocol::ClientMessage_InviteUser* release_invite_user_message();
  inline void set_allocated_invite_user_message(::protocol::ClientMessage_InviteUser* invite_user_message);

  // optional .protocol.ClientMessage.RemoveUser remove_user_message = 12;
  inline bool has_remove_user_message() const;
  inline void clear_remove_user_message();
  static const int kRemoveUserMessageFieldNumber = 12;
  inline const ::protocol::ClientMessage_RemoveUser& remove_user_message() const;
  inline ::protocol::ClientMessage_RemoveUser* mutable_remove_user_message();
  inline ::protocol::ClientMessage_RemoveUser* release_remove_user_message();
  inline void set_allocated_remove_user_message(::protocol::ClientMessage_RemoveUser* remove_user_message);

  // optional .protocol.ClientMessage.UserInfo user_info_message = 13;
  inline bool has_user_info_message() const;
  inline void clear_user_info_message();
  static const int kUserInfoMessageFieldNumber = 13;
  inline const ::protocol::ClientMessage_UserInfo& user_info_message() const;
  inline ::protocol::ClientMessage_UserInfo* mutable_user_info_message();
  inline ::protocol::ClientMessage_UserInfo* release_user_info_message();
  inline void set_allocated_user_info_message(::protocol::ClientMessage_UserInfo* user_info_message);

  // optional .protocol.ClientMessage.UpdateServer update_server_message = 14;
  inline bool has_update_server_message() const;
  inline void clear_update_server_message();
  static const int kUpdateServerMessageFieldNumber = 14;
  inline const ::protocol::ClientMessage_UpdateServer& update_server_message() const;
  inline ::protocol::ClientMessage_UpdateServer* mutable_update_server_message();
  inline ::protocol::ClientMessage_UpdateServer* release_update_server_message();
  inline void set_allocated_update_server_message(::protocol::ClientMessage_UpdateServer* update_server_message);

  // optional .protocol.ClientMessage.StopServer stop_server_message = 15;
  inline bool has_stop_server_message() const;
  inline void clear_stop_server_message();
  static const int kStopServerMessageFieldNumber = 15;
  inline const ::protocol::ClientMessage_StopServer& stop_server_message() const;
  inline ::protocol::ClientMessage_StopServer* mutable_stop_server_message();
  inline ::protocol::ClientMessage_StopServer* release_stop_server_message();
  inline void set_allocated_stop_server_message(::protocol::ClientMessage_StopServer* stop_server_message);

  // optional .protocol.ClientMessage.SignKey sign_key_message = 16;
  inline bool has_sign_key_message() const;
  inline void clear_sign_key_message();
  static const int kSignKeyMessageFieldNumber = 16;
  inline const ::protocol::ClientMessage_SignKey& sign_key_message() const;
  inline ::protocol::ClientMessage_SignKey* mutable_sign_key_message();
  inline ::protocol::ClientMessage_SignKey* release_sign_key_message();
  inline void set_allocated_sign_key_message(::protocol::ClientMessage_SignKey* sign_key_message);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_register_message();
  inline void clear_has_register_message();
  inline void set_has_unregister_message();
  inline void clear_has_unregister_message();
  inline void set_has_login_message();
  inline void clear_has_login_message();
  inline void set_has_logout_message();
  inline void clear_has_logout_message();
  inline void set_has_list_networks_message();
  inline void clear_has_list_networks_message();
  inline void set_has_list_my_networks_message();
  inline void clear_has_list_my_networks_message();
  inline void set_has_list_servers_message();
  inline void clear_has_list_servers_message();
  inline void set_has_create_network_message();
  inline void clear_has_create_network_message();
  inline void set_has_delete_network_message();
  inline void clear_has_delete_network_message();
  inline void set_has_invite_user_message();
  inline void clear_has_invite_user_message();
  inline void set_has_remove_user_message();
  inline void clear_has_remove_user_message();
  inline void set_has_user_info_message();
  inline void clear_has_user_info_message();
  inline void set_has_update_server_message();
  inline void clear_has_update_server_message();
  inline void set_has_stop_server_message();
  inline void clear_has_stop_server_message();
  inline void set_has_sign_key_message();
  inline void clear_has_sign_key_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::ClientMessage_Register* register_message_;
  ::protocol::ClientMessage_Unregister* unregister_message_;
  ::protocol::ClientMessage_Login* login_message_;
  ::protocol::ClientMessage_Logout* logout_message_;
  ::protocol::ClientMessage_ListNetworks* list_networks_message_;
  ::protocol::ClientMessage_ListMyNetworks* list_my_networks_message_;
  ::protocol::ClientMessage_ListServers* list_servers_message_;
  ::protocol::ClientMessage_CreateNetwork* create_network_message_;
  ::protocol::ClientMessage_DeleteNetwork* delete_network_message_;
  ::protocol::ClientMessage_InviteUser* invite_user_message_;
  ::protocol::ClientMessage_RemoveUser* remove_user_message_;
  ::protocol::ClientMessage_UserInfo* user_info_message_;
  ::protocol::ClientMessage_UpdateServer* update_server_message_;
  ::protocol::ClientMessage_StopServer* stop_server_message_;
  ::protocol::ClientMessage_SignKey* sign_key_message_;
  int request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_Register : public ::google::protobuf::Message {
 public:
  NodeMessage_Register();
  virtual ~NodeMessage_Register();

  NodeMessage_Register(const NodeMessage_Register& from);

  inline NodeMessage_Register& operator=(const NodeMessage_Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_Register& default_instance();

  void Swap(NodeMessage_Register* other);

  // implements Message ----------------------------------------------

  NodeMessage_Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_Register& from);
  void MergeFrom(const NodeMessage_Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_certificate = 1;
  inline bool has_user_certificate() const;
  inline void clear_user_certificate();
  static const int kUserCertificateFieldNumber = 1;
  inline const ::std::string& user_certificate() const;
  inline void set_user_certificate(const ::std::string& value);
  inline void set_user_certificate(const char* value);
  inline void set_user_certificate(const char* value, size_t size);
  inline ::std::string* mutable_user_certificate();
  inline ::std::string* release_user_certificate();
  inline void set_allocated_user_certificate(::std::string* user_certificate);

  // required string node_certificate = 2;
  inline bool has_node_certificate() const;
  inline void clear_node_certificate();
  static const int kNodeCertificateFieldNumber = 2;
  inline const ::std::string& node_certificate() const;
  inline void set_node_certificate(const ::std::string& value);
  inline void set_node_certificate(const char* value);
  inline void set_node_certificate(const char* value, size_t size);
  inline ::std::string* mutable_node_certificate();
  inline ::std::string* release_node_certificate();
  inline void set_allocated_node_certificate(::std::string* node_certificate);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.Register)
 private:
  inline void set_has_user_certificate();
  inline void clear_has_user_certificate();
  inline void set_has_node_certificate();
  inline void clear_has_node_certificate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_certificate_;
  ::std::string* node_certificate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_Register* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_Login : public ::google::protobuf::Message {
 public:
  NodeMessage_Login();
  virtual ~NodeMessage_Login();

  NodeMessage_Login(const NodeMessage_Login& from);

  inline NodeMessage_Login& operator=(const NodeMessage_Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_Login& default_instance();

  void Swap(NodeMessage_Login* other);

  // implements Message ----------------------------------------------

  NodeMessage_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_Login& from);
  void MergeFrom(const NodeMessage_Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // optional string node_certificate = 2;
  inline bool has_node_certificate() const;
  inline void clear_node_certificate();
  static const int kNodeCertificateFieldNumber = 2;
  inline const ::std::string& node_certificate() const;
  inline void set_node_certificate(const ::std::string& value);
  inline void set_node_certificate(const char* value);
  inline void set_node_certificate(const char* value, size_t size);
  inline ::std::string* mutable_node_certificate();
  inline ::std::string* release_node_certificate();
  inline void set_allocated_node_certificate(::std::string* node_certificate);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.Login)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_node_certificate();
  inline void clear_has_node_certificate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::std::string* node_certificate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_Login* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_ListNetworks_Network : public ::google::protobuf::Message {
 public:
  NodeMessage_ListNetworks_Network();
  virtual ~NodeMessage_ListNetworks_Network();

  NodeMessage_ListNetworks_Network(const NodeMessage_ListNetworks_Network& from);

  inline NodeMessage_ListNetworks_Network& operator=(const NodeMessage_ListNetworks_Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_ListNetworks_Network& default_instance();

  void Swap(NodeMessage_ListNetworks_Network* other);

  // implements Message ----------------------------------------------

  NodeMessage_ListNetworks_Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_ListNetworks_Network& from);
  void MergeFrom(const NodeMessage_ListNetworks_Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string creator_name = 2;
  inline bool has_creator_name() const;
  inline void clear_creator_name();
  static const int kCreatorNameFieldNumber = 2;
  inline const ::std::string& creator_name() const;
  inline void set_creator_name(const ::std::string& value);
  inline void set_creator_name(const char* value);
  inline void set_creator_name(const char* value, size_t size);
  inline ::std::string* mutable_creator_name();
  inline ::std::string* release_creator_name();
  inline void set_allocated_creator_name(::std::string* creator_name);

  // optional string creator_email = 3;
  inline bool has_creator_email() const;
  inline void clear_creator_email();
  static const int kCreatorEmailFieldNumber = 3;
  inline const ::std::string& creator_email() const;
  inline void set_creator_email(const ::std::string& value);
  inline void set_creator_email(const char* value);
  inline void set_creator_email(const char* value, size_t size);
  inline ::std::string* mutable_creator_email();
  inline ::std::string* release_creator_email();
  inline void set_allocated_creator_email(::std::string* creator_email);

  // required .protocol.ClientMessage.CreateNetwork.AccessRights access_rights = 4;
  inline bool has_access_rights() const;
  inline void clear_access_rights();
  static const int kAccessRightsFieldNumber = 4;
  inline ::protocol::ClientMessage_CreateNetwork_AccessRights access_rights() const;
  inline void set_access_rights(::protocol::ClientMessage_CreateNetwork_AccessRights value);

  // required .protocol.ClientMessage.CreateNetwork.ParticipationRights participation_rights = 5;
  inline bool has_participation_rights() const;
  inline void clear_participation_rights();
  static const int kParticipationRightsFieldNumber = 5;
  inline ::protocol::ClientMessage_CreateNetwork_ParticipationRights participation_rights() const;
  inline void set_participation_rights(::protocol::ClientMessage_CreateNetwork_ParticipationRights value);

  // optional string protocol_name = 6;
  inline bool has_protocol_name() const;
  inline void clear_protocol_name();
  static const int kProtocolNameFieldNumber = 6;
  inline const ::std::string& protocol_name() const;
  inline void set_protocol_name(const ::std::string& value);
  inline void set_protocol_name(const char* value);
  inline void set_protocol_name(const char* value, size_t size);
  inline ::std::string* mutable_protocol_name();
  inline ::std::string* release_protocol_name();
  inline void set_allocated_protocol_name(::std::string* protocol_name);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.ListNetworks.Network)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_creator_name();
  inline void clear_has_creator_name();
  inline void set_has_creator_email();
  inline void clear_has_creator_email();
  inline void set_has_access_rights();
  inline void clear_has_access_rights();
  inline void set_has_participation_rights();
  inline void clear_has_participation_rights();
  inline void set_has_protocol_name();
  inline void clear_has_protocol_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* creator_name_;
  ::std::string* creator_email_;
  int access_rights_;
  int participation_rights_;
  ::std::string* protocol_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_ListNetworks_Network* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_ListNetworks : public ::google::protobuf::Message {
 public:
  NodeMessage_ListNetworks();
  virtual ~NodeMessage_ListNetworks();

  NodeMessage_ListNetworks(const NodeMessage_ListNetworks& from);

  inline NodeMessage_ListNetworks& operator=(const NodeMessage_ListNetworks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_ListNetworks& default_instance();

  void Swap(NodeMessage_ListNetworks* other);

  // implements Message ----------------------------------------------

  NodeMessage_ListNetworks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_ListNetworks& from);
  void MergeFrom(const NodeMessage_ListNetworks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeMessage_ListNetworks_Network Network;

  // accessors -------------------------------------------------------

  // repeated .protocol.NodeMessage.ListNetworks.Network network_list = 1;
  inline int network_list_size() const;
  inline void clear_network_list();
  static const int kNetworkListFieldNumber = 1;
  inline const ::protocol::NodeMessage_ListNetworks_Network& network_list(int index) const;
  inline ::protocol::NodeMessage_ListNetworks_Network* mutable_network_list(int index);
  inline ::protocol::NodeMessage_ListNetworks_Network* add_network_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >&
      network_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >*
      mutable_network_list();

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.ListNetworks)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network > network_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_ListNetworks* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_ListMyNetworks : public ::google::protobuf::Message {
 public:
  NodeMessage_ListMyNetworks();
  virtual ~NodeMessage_ListMyNetworks();

  NodeMessage_ListMyNetworks(const NodeMessage_ListMyNetworks& from);

  inline NodeMessage_ListMyNetworks& operator=(const NodeMessage_ListMyNetworks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_ListMyNetworks& default_instance();

  void Swap(NodeMessage_ListMyNetworks* other);

  // implements Message ----------------------------------------------

  NodeMessage_ListMyNetworks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_ListMyNetworks& from);
  void MergeFrom(const NodeMessage_ListMyNetworks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.NodeMessage.ListNetworks.Network network_list = 1;
  inline int network_list_size() const;
  inline void clear_network_list();
  static const int kNetworkListFieldNumber = 1;
  inline const ::protocol::NodeMessage_ListNetworks_Network& network_list(int index) const;
  inline ::protocol::NodeMessage_ListNetworks_Network* mutable_network_list(int index);
  inline ::protocol::NodeMessage_ListNetworks_Network* add_network_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >&
      network_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >*
      mutable_network_list();

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.ListMyNetworks)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network > network_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_ListMyNetworks* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_ListServers_Server : public ::google::protobuf::Message {
 public:
  NodeMessage_ListServers_Server();
  virtual ~NodeMessage_ListServers_Server();

  NodeMessage_ListServers_Server(const NodeMessage_ListServers_Server& from);

  inline NodeMessage_ListServers_Server& operator=(const NodeMessage_ListServers_Server& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_ListServers_Server& default_instance();

  void Swap(NodeMessage_ListServers_Server* other);

  // implements Message ----------------------------------------------

  NodeMessage_ListServers_Server* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_ListServers_Server& from);
  void MergeFrom(const NodeMessage_ListServers_Server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string ip_address = 2;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const char* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // required int32 port_number = 3;
  inline bool has_port_number() const;
  inline void clear_port_number();
  static const int kPortNumberFieldNumber = 3;
  inline ::google::protobuf::int32 port_number() const;
  inline void set_port_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.ListServers.Server)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_port_number();
  inline void clear_has_port_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* ip_address_;
  ::google::protobuf::int32 port_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_ListServers_Server* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_ListServers : public ::google::protobuf::Message {
 public:
  NodeMessage_ListServers();
  virtual ~NodeMessage_ListServers();

  NodeMessage_ListServers(const NodeMessage_ListServers& from);

  inline NodeMessage_ListServers& operator=(const NodeMessage_ListServers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_ListServers& default_instance();

  void Swap(NodeMessage_ListServers* other);

  // implements Message ----------------------------------------------

  NodeMessage_ListServers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_ListServers& from);
  void MergeFrom(const NodeMessage_ListServers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeMessage_ListServers_Server Server;

  // accessors -------------------------------------------------------

  // repeated .protocol.NodeMessage.ListServers list_servers = 1;
  inline int list_servers_size() const;
  inline void clear_list_servers();
  static const int kListServersFieldNumber = 1;
  inline const ::protocol::NodeMessage_ListServers& list_servers(int index) const;
  inline ::protocol::NodeMessage_ListServers* mutable_list_servers(int index);
  inline ::protocol::NodeMessage_ListServers* add_list_servers();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListServers >&
      list_servers() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListServers >*
      mutable_list_servers();

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.ListServers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListServers > list_servers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_ListServers* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_UserInfo : public ::google::protobuf::Message {
 public:
  NodeMessage_UserInfo();
  virtual ~NodeMessage_UserInfo();

  NodeMessage_UserInfo(const NodeMessage_UserInfo& from);

  inline NodeMessage_UserInfo& operator=(const NodeMessage_UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_UserInfo& default_instance();

  void Swap(NodeMessage_UserInfo* other);

  // implements Message ----------------------------------------------

  NodeMessage_UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_UserInfo& from);
  void MergeFrom(const NodeMessage_UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_public_key = 1;
  inline bool has_user_public_key() const;
  inline void clear_user_public_key();
  static const int kUserPublicKeyFieldNumber = 1;
  inline const ::std::string& user_public_key() const;
  inline void set_user_public_key(const ::std::string& value);
  inline void set_user_public_key(const char* value);
  inline void set_user_public_key(const char* value, size_t size);
  inline ::std::string* mutable_user_public_key();
  inline ::std::string* release_user_public_key();
  inline void set_allocated_user_public_key(::std::string* user_public_key);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.UserInfo)
 private:
  inline void set_has_user_public_key();
  inline void clear_has_user_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_public_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_UpdateServer : public ::google::protobuf::Message {
 public:
  NodeMessage_UpdateServer();
  virtual ~NodeMessage_UpdateServer();

  NodeMessage_UpdateServer(const NodeMessage_UpdateServer& from);

  inline NodeMessage_UpdateServer& operator=(const NodeMessage_UpdateServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_UpdateServer& default_instance();

  void Swap(NodeMessage_UpdateServer* other);

  // implements Message ----------------------------------------------

  NodeMessage_UpdateServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_UpdateServer& from);
  void MergeFrom(const NodeMessage_UpdateServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seconds_to_update = 1;
  inline bool has_seconds_to_update() const;
  inline void clear_seconds_to_update();
  static const int kSecondsToUpdateFieldNumber = 1;
  inline ::google::protobuf::int32 seconds_to_update() const;
  inline void set_seconds_to_update(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.UpdateServer)
 private:
  inline void set_has_seconds_to_update();
  inline void clear_has_seconds_to_update();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seconds_to_update_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_UpdateServer* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage_SignKey : public ::google::protobuf::Message {
 public:
  NodeMessage_SignKey();
  virtual ~NodeMessage_SignKey();

  NodeMessage_SignKey(const NodeMessage_SignKey& from);

  inline NodeMessage_SignKey& operator=(const NodeMessage_SignKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage_SignKey& default_instance();

  void Swap(NodeMessage_SignKey* other);

  // implements Message ----------------------------------------------

  NodeMessage_SignKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage_SignKey& from);
  void MergeFrom(const NodeMessage_SignKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_certificate = 1;
  inline bool has_user_certificate() const;
  inline void clear_user_certificate();
  static const int kUserCertificateFieldNumber = 1;
  inline const ::std::string& user_certificate() const;
  inline void set_user_certificate(const ::std::string& value);
  inline void set_user_certificate(const char* value);
  inline void set_user_certificate(const char* value, size_t size);
  inline ::std::string* mutable_user_certificate();
  inline ::std::string* release_user_certificate();
  inline void set_allocated_user_certificate(::std::string* user_certificate);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage.SignKey)
 private:
  inline void set_has_user_certificate();
  inline void clear_has_user_certificate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_certificate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage_SignKey* default_instance_;
};
// -------------------------------------------------------------------

class NodeMessage : public ::google::protobuf::Message {
 public:
  NodeMessage();
  virtual ~NodeMessage();

  NodeMessage(const NodeMessage& from);

  inline NodeMessage& operator=(const NodeMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMessage& default_instance();

  void Swap(NodeMessage* other);

  // implements Message ----------------------------------------------

  NodeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMessage& from);
  void MergeFrom(const NodeMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeMessage_Register Register;
  typedef NodeMessage_Login Login;
  typedef NodeMessage_ListNetworks ListNetworks;
  typedef NodeMessage_ListMyNetworks ListMyNetworks;
  typedef NodeMessage_ListServers ListServers;
  typedef NodeMessage_UserInfo UserInfo;
  typedef NodeMessage_UpdateServer UpdateServer;
  typedef NodeMessage_SignKey SignKey;

  typedef NodeMessage_ResponseType ResponseType;
  static const ResponseType OK = NodeMessage_ResponseType_OK;
  static const ResponseType INTERNAL_SERVER_ERROR = NodeMessage_ResponseType_INTERNAL_SERVER_ERROR;
  static const ResponseType BAD_REQUEST = NodeMessage_ResponseType_BAD_REQUEST;
  static const ResponseType NO_PRIVILAGES = NodeMessage_ResponseType_NO_PRIVILAGES;
  static const ResponseType NOT_LOGGED = NodeMessage_ResponseType_NOT_LOGGED;
  static const ResponseType BAD_CREDENTIALS = NodeMessage_ResponseType_BAD_CREDENTIALS;
  static const ResponseType NO_SUCH_USER = NodeMessage_ResponseType_NO_SUCH_USER;
  static const ResponseType NO_SUCH_NETWORK = NodeMessage_ResponseType_NO_SUCH_NETWORK;
  static const ResponseType BAD_DATA = NodeMessage_ResponseType_BAD_DATA;
  static inline bool ResponseType_IsValid(int value) {
    return NodeMessage_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    NodeMessage_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    NodeMessage_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    NodeMessage_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return NodeMessage_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return NodeMessage_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return NodeMessage_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protocol.NodeMessage.ResponseType response_type = 1;
  inline bool has_response_type() const;
  inline void clear_response_type();
  static const int kResponseTypeFieldNumber = 1;
  inline ::protocol::NodeMessage_ResponseType response_type() const;
  inline void set_response_type(::protocol::NodeMessage_ResponseType value);

  // optional .protocol.NodeMessage.Register register_response = 2;
  inline bool has_register_response() const;
  inline void clear_register_response();
  static const int kRegisterResponseFieldNumber = 2;
  inline const ::protocol::NodeMessage_Register& register_response() const;
  inline ::protocol::NodeMessage_Register* mutable_register_response();
  inline ::protocol::NodeMessage_Register* release_register_response();
  inline void set_allocated_register_response(::protocol::NodeMessage_Register* register_response);

  // optional .protocol.NodeMessage.Login login_response = 3;
  inline bool has_login_response() const;
  inline void clear_login_response();
  static const int kLoginResponseFieldNumber = 3;
  inline const ::protocol::NodeMessage_Login& login_response() const;
  inline ::protocol::NodeMessage_Login* mutable_login_response();
  inline ::protocol::NodeMessage_Login* release_login_response();
  inline void set_allocated_login_response(::protocol::NodeMessage_Login* login_response);

  // optional .protocol.NodeMessage.ListNetworks list_networks_response = 5;
  inline bool has_list_networks_response() const;
  inline void clear_list_networks_response();
  static const int kListNetworksResponseFieldNumber = 5;
  inline const ::protocol::NodeMessage_ListNetworks& list_networks_response() const;
  inline ::protocol::NodeMessage_ListNetworks* mutable_list_networks_response();
  inline ::protocol::NodeMessage_ListNetworks* release_list_networks_response();
  inline void set_allocated_list_networks_response(::protocol::NodeMessage_ListNetworks* list_networks_response);

  // optional .protocol.NodeMessage.ListMyNetworks list_my_networks_response = 6;
  inline bool has_list_my_networks_response() const;
  inline void clear_list_my_networks_response();
  static const int kListMyNetworksResponseFieldNumber = 6;
  inline const ::protocol::NodeMessage_ListMyNetworks& list_my_networks_response() const;
  inline ::protocol::NodeMessage_ListMyNetworks* mutable_list_my_networks_response();
  inline ::protocol::NodeMessage_ListMyNetworks* release_list_my_networks_response();
  inline void set_allocated_list_my_networks_response(::protocol::NodeMessage_ListMyNetworks* list_my_networks_response);

  // optional .protocol.NodeMessage.ListServers list_servers_response = 7;
  inline bool has_list_servers_response() const;
  inline void clear_list_servers_response();
  static const int kListServersResponseFieldNumber = 7;
  inline const ::protocol::NodeMessage_ListServers& list_servers_response() const;
  inline ::protocol::NodeMessage_ListServers* mutable_list_servers_response();
  inline ::protocol::NodeMessage_ListServers* release_list_servers_response();
  inline void set_allocated_list_servers_response(::protocol::NodeMessage_ListServers* list_servers_response);

  // optional .protocol.NodeMessage.UserInfo user_info_response = 13;
  inline bool has_user_info_response() const;
  inline void clear_user_info_response();
  static const int kUserInfoResponseFieldNumber = 13;
  inline const ::protocol::NodeMessage_UserInfo& user_info_response() const;
  inline ::protocol::NodeMessage_UserInfo* mutable_user_info_response();
  inline ::protocol::NodeMessage_UserInfo* release_user_info_response();
  inline void set_allocated_user_info_response(::protocol::NodeMessage_UserInfo* user_info_response);

  // optional .protocol.NodeMessage.UpdateServer update_server_response = 14;
  inline bool has_update_server_response() const;
  inline void clear_update_server_response();
  static const int kUpdateServerResponseFieldNumber = 14;
  inline const ::protocol::NodeMessage_UpdateServer& update_server_response() const;
  inline ::protocol::NodeMessage_UpdateServer* mutable_update_server_response();
  inline ::protocol::NodeMessage_UpdateServer* release_update_server_response();
  inline void set_allocated_update_server_response(::protocol::NodeMessage_UpdateServer* update_server_response);

  // optional .protocol.NodeMessage.SignKey sign_key_response = 16;
  inline bool has_sign_key_response() const;
  inline void clear_sign_key_response();
  static const int kSignKeyResponseFieldNumber = 16;
  inline const ::protocol::NodeMessage_SignKey& sign_key_response() const;
  inline ::protocol::NodeMessage_SignKey* mutable_sign_key_response();
  inline ::protocol::NodeMessage_SignKey* release_sign_key_response();
  inline void set_allocated_sign_key_response(::protocol::NodeMessage_SignKey* sign_key_response);

  // @@protoc_insertion_point(class_scope:protocol.NodeMessage)
 private:
  inline void set_has_response_type();
  inline void clear_has_response_type();
  inline void set_has_register_response();
  inline void clear_has_register_response();
  inline void set_has_login_response();
  inline void clear_has_login_response();
  inline void set_has_list_networks_response();
  inline void clear_has_list_networks_response();
  inline void set_has_list_my_networks_response();
  inline void clear_has_list_my_networks_response();
  inline void set_has_list_servers_response();
  inline void clear_has_list_servers_response();
  inline void set_has_user_info_response();
  inline void clear_has_user_info_response();
  inline void set_has_update_server_response();
  inline void clear_has_update_server_response();
  inline void set_has_sign_key_response();
  inline void clear_has_sign_key_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::NodeMessage_Register* register_response_;
  ::protocol::NodeMessage_Login* login_response_;
  ::protocol::NodeMessage_ListNetworks* list_networks_response_;
  ::protocol::NodeMessage_ListMyNetworks* list_my_networks_response_;
  ::protocol::NodeMessage_ListServers* list_servers_response_;
  ::protocol::NodeMessage_UserInfo* user_info_response_;
  ::protocol::NodeMessage_UpdateServer* update_server_response_;
  ::protocol::NodeMessage_SignKey* sign_key_response_;
  int response_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_sp2p_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_sp2p_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static NodeMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientMessage_Register

// required string username = 1;
inline bool ClientMessage_Register::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_Register::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_Register::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_Register::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ClientMessage_Register::username() const {
  return *username_;
}
inline void ClientMessage_Register::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_Register::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_Register::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Register::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ClientMessage_Register::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Register::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool ClientMessage_Register::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_Register::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_Register::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_Register::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ClientMessage_Register::password() const {
  return *password_;
}
inline void ClientMessage_Register::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientMessage_Register::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientMessage_Register::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Register::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ClientMessage_Register::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Register::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string public_key = 3;
inline bool ClientMessage_Register::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_Register::set_has_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_Register::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_Register::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& ClientMessage_Register::public_key() const {
  return *public_key_;
}
inline void ClientMessage_Register::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ClientMessage_Register::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ClientMessage_Register::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Register::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* ClientMessage_Register::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Register::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_Unregister

// required string cookie = 1;
inline bool ClientMessage_Unregister::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_Unregister::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_Unregister::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_Unregister::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_Unregister::cookie() const {
  return *cookie_;
}
inline void ClientMessage_Unregister::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_Unregister::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_Unregister::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Unregister::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_Unregister::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Unregister::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_Login

// required string username = 1;
inline bool ClientMessage_Login::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_Login::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ClientMessage_Login::username() const {
  return *username_;
}
inline void ClientMessage_Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ClientMessage_Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool ClientMessage_Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ClientMessage_Login::password() const {
  return *password_;
}
inline void ClientMessage_Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientMessage_Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientMessage_Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ClientMessage_Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_Logout

// required string cookie = 1;
inline bool ClientMessage_Logout::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_Logout::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_Logout::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_Logout::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_Logout::cookie() const {
  return *cookie_;
}
inline void ClientMessage_Logout::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_Logout::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_Logout::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_Logout::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_Logout::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_Logout::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_ListNetworks

// required string cookie = 1;
inline bool ClientMessage_ListNetworks::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_ListNetworks::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_ListNetworks::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_ListNetworks::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_ListNetworks::cookie() const {
  return *cookie_;
}
inline void ClientMessage_ListNetworks::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListNetworks::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListNetworks::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_ListNetworks::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_ListNetworks::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_ListNetworks::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_ListMyNetworks

// required string cookie = 1;
inline bool ClientMessage_ListMyNetworks::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_ListMyNetworks::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_ListMyNetworks::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_ListMyNetworks::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_ListMyNetworks::cookie() const {
  return *cookie_;
}
inline void ClientMessage_ListMyNetworks::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListMyNetworks::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListMyNetworks::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_ListMyNetworks::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_ListMyNetworks::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_ListMyNetworks::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_ListServers

// required string cookie = 1;
inline bool ClientMessage_ListServers::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_ListServers::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_ListServers::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_ListServers::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_ListServers::cookie() const {
  return *cookie_;
}
inline void ClientMessage_ListServers::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListServers::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_ListServers::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_ListServers::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_ListServers::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_ListServers::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 2;
inline bool ClientMessage_ListServers::has_network_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_ListServers::set_has_network_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_ListServers::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_ListServers::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_ListServers::network_name() const {
  return *network_name_;
}
inline void ClientMessage_ListServers::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_ListServers::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_ListServers::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_ListServers::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_ListServers::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_ListServers::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_CreateNetwork

// required string cookie = 1;
inline bool ClientMessage_CreateNetwork::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_CreateNetwork::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_CreateNetwork::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_CreateNetwork::cookie() const {
  return *cookie_;
}
inline void ClientMessage_CreateNetwork::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_CreateNetwork::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_CreateNetwork::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_CreateNetwork::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 2;
inline bool ClientMessage_CreateNetwork::has_network_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_network_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_CreateNetwork::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_CreateNetwork::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_CreateNetwork::network_name() const {
  return *network_name_;
}
inline void ClientMessage_CreateNetwork::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_CreateNetwork::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_CreateNetwork::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_CreateNetwork::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protocol.ClientMessage.CreateNetwork.AccessRights access_rights = 3;
inline bool ClientMessage_CreateNetwork::has_access_rights() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_access_rights() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_CreateNetwork::clear_has_access_rights() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_CreateNetwork::clear_access_rights() {
  access_rights_ = 1;
  clear_has_access_rights();
}
inline ::protocol::ClientMessage_CreateNetwork_AccessRights ClientMessage_CreateNetwork::access_rights() const {
  return static_cast< ::protocol::ClientMessage_CreateNetwork_AccessRights >(access_rights_);
}
inline void ClientMessage_CreateNetwork::set_access_rights(::protocol::ClientMessage_CreateNetwork_AccessRights value) {
  assert(::protocol::ClientMessage_CreateNetwork_AccessRights_IsValid(value));
  set_has_access_rights();
  access_rights_ = value;
}

// required .protocol.ClientMessage.CreateNetwork.Visiblity visibility = 4;
inline bool ClientMessage_CreateNetwork::has_visibility() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_visibility() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage_CreateNetwork::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage_CreateNetwork::clear_visibility() {
  visibility_ = 3;
  clear_has_visibility();
}
inline ::protocol::ClientMessage_CreateNetwork_Visiblity ClientMessage_CreateNetwork::visibility() const {
  return static_cast< ::protocol::ClientMessage_CreateNetwork_Visiblity >(visibility_);
}
inline void ClientMessage_CreateNetwork::set_visibility(::protocol::ClientMessage_CreateNetwork_Visiblity value) {
  assert(::protocol::ClientMessage_CreateNetwork_Visiblity_IsValid(value));
  set_has_visibility();
  visibility_ = value;
}

// required .protocol.ClientMessage.CreateNetwork.ParticipationRights participation_rights = 5;
inline bool ClientMessage_CreateNetwork::has_participation_rights() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_participation_rights() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage_CreateNetwork::clear_has_participation_rights() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage_CreateNetwork::clear_participation_rights() {
  participation_rights_ = 5;
  clear_has_participation_rights();
}
inline ::protocol::ClientMessage_CreateNetwork_ParticipationRights ClientMessage_CreateNetwork::participation_rights() const {
  return static_cast< ::protocol::ClientMessage_CreateNetwork_ParticipationRights >(participation_rights_);
}
inline void ClientMessage_CreateNetwork::set_participation_rights(::protocol::ClientMessage_CreateNetwork_ParticipationRights value) {
  assert(::protocol::ClientMessage_CreateNetwork_ParticipationRights_IsValid(value));
  set_has_participation_rights();
  participation_rights_ = value;
}

// optional string creator_email = 6;
inline bool ClientMessage_CreateNetwork::has_creator_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_creator_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage_CreateNetwork::clear_has_creator_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage_CreateNetwork::clear_creator_email() {
  if (creator_email_ != &::google::protobuf::internal::kEmptyString) {
    creator_email_->clear();
  }
  clear_has_creator_email();
}
inline const ::std::string& ClientMessage_CreateNetwork::creator_email() const {
  return *creator_email_;
}
inline void ClientMessage_CreateNetwork::set_creator_email(const ::std::string& value) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_creator_email(const char* value) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_creator_email(const char* value, size_t size) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_CreateNetwork::mutable_creator_email() {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  return creator_email_;
}
inline ::std::string* ClientMessage_CreateNetwork::release_creator_email() {
  clear_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_email_;
    creator_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_CreateNetwork::set_allocated_creator_email(::std::string* creator_email) {
  if (creator_email_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_email_;
  }
  if (creator_email) {
    set_has_creator_email();
    creator_email_ = creator_email;
  } else {
    clear_has_creator_email();
    creator_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protocol_name = 7;
inline bool ClientMessage_CreateNetwork::has_protocol_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientMessage_CreateNetwork::set_has_protocol_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientMessage_CreateNetwork::clear_has_protocol_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientMessage_CreateNetwork::clear_protocol_name() {
  if (protocol_name_ != &::google::protobuf::internal::kEmptyString) {
    protocol_name_->clear();
  }
  clear_has_protocol_name();
}
inline const ::std::string& ClientMessage_CreateNetwork::protocol_name() const {
  return *protocol_name_;
}
inline void ClientMessage_CreateNetwork::set_protocol_name(const ::std::string& value) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_protocol_name(const char* value) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(value);
}
inline void ClientMessage_CreateNetwork::set_protocol_name(const char* value, size_t size) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_CreateNetwork::mutable_protocol_name() {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  return protocol_name_;
}
inline ::std::string* ClientMessage_CreateNetwork::release_protocol_name() {
  clear_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_name_;
    protocol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_CreateNetwork::set_allocated_protocol_name(::std::string* protocol_name) {
  if (protocol_name_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_name_;
  }
  if (protocol_name) {
    set_has_protocol_name();
    protocol_name_ = protocol_name;
  } else {
    clear_has_protocol_name();
    protocol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_DeleteNetwork

// required string cookie = 1;
inline bool ClientMessage_DeleteNetwork::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_DeleteNetwork::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_DeleteNetwork::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_DeleteNetwork::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_DeleteNetwork::cookie() const {
  return *cookie_;
}
inline void ClientMessage_DeleteNetwork::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_DeleteNetwork::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_DeleteNetwork::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_DeleteNetwork::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_DeleteNetwork::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_DeleteNetwork::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool ClientMessage_DeleteNetwork::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_DeleteNetwork::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_DeleteNetwork::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_DeleteNetwork::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientMessage_DeleteNetwork::name() const {
  return *name_;
}
inline void ClientMessage_DeleteNetwork::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientMessage_DeleteNetwork::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientMessage_DeleteNetwork::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_DeleteNetwork::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientMessage_DeleteNetwork::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_DeleteNetwork::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_InviteUser

// required string cookie = 1;
inline bool ClientMessage_InviteUser::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_InviteUser::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_InviteUser::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_InviteUser::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_InviteUser::cookie() const {
  return *cookie_;
}
inline void ClientMessage_InviteUser::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_InviteUser::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_InviteUser::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_InviteUser::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_InviteUser::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_InviteUser::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 2;
inline bool ClientMessage_InviteUser::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_InviteUser::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_InviteUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_InviteUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ClientMessage_InviteUser::username() const {
  return *username_;
}
inline void ClientMessage_InviteUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_InviteUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_InviteUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_InviteUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ClientMessage_InviteUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_InviteUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 3;
inline bool ClientMessage_InviteUser::has_network_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_InviteUser::set_has_network_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_InviteUser::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_InviteUser::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_InviteUser::network_name() const {
  return *network_name_;
}
inline void ClientMessage_InviteUser::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_InviteUser::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_InviteUser::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_InviteUser::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_InviteUser::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_InviteUser::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_RemoveUser

// required string cookie = 1;
inline bool ClientMessage_RemoveUser::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_RemoveUser::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_RemoveUser::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_RemoveUser::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_RemoveUser::cookie() const {
  return *cookie_;
}
inline void ClientMessage_RemoveUser::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_RemoveUser::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_RemoveUser::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_RemoveUser::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_RemoveUser::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_RemoveUser::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 2;
inline bool ClientMessage_RemoveUser::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_RemoveUser::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_RemoveUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_RemoveUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ClientMessage_RemoveUser::username() const {
  return *username_;
}
inline void ClientMessage_RemoveUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_RemoveUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_RemoveUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_RemoveUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ClientMessage_RemoveUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_RemoveUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 3;
inline bool ClientMessage_RemoveUser::has_network_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_RemoveUser::set_has_network_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_RemoveUser::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_RemoveUser::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_RemoveUser::network_name() const {
  return *network_name_;
}
inline void ClientMessage_RemoveUser::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_RemoveUser::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_RemoveUser::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_RemoveUser::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_RemoveUser::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_RemoveUser::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_UserInfo

// required string cookie = 1;
inline bool ClientMessage_UserInfo::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_UserInfo::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_UserInfo::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_UserInfo::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_UserInfo::cookie() const {
  return *cookie_;
}
inline void ClientMessage_UserInfo::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_UserInfo::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_UserInfo::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_UserInfo::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_UserInfo::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_UserInfo::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 2;
inline bool ClientMessage_UserInfo::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_UserInfo::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_UserInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_UserInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ClientMessage_UserInfo::username() const {
  return *username_;
}
inline void ClientMessage_UserInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_UserInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ClientMessage_UserInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_UserInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ClientMessage_UserInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_UserInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 3;
inline bool ClientMessage_UserInfo::has_network_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_UserInfo::set_has_network_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_UserInfo::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_UserInfo::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_UserInfo::network_name() const {
  return *network_name_;
}
inline void ClientMessage_UserInfo::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_UserInfo::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_UserInfo::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_UserInfo::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_UserInfo::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_UserInfo::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_UpdateServer

// required string cookie = 1;
inline bool ClientMessage_UpdateServer::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_UpdateServer::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_UpdateServer::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_UpdateServer::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_UpdateServer::cookie() const {
  return *cookie_;
}
inline void ClientMessage_UpdateServer::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_UpdateServer::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_UpdateServer::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_UpdateServer::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_UpdateServer::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_UpdateServer::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 2;
inline bool ClientMessage_UpdateServer::has_network_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_UpdateServer::set_has_network_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_UpdateServer::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_UpdateServer::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_UpdateServer::network_name() const {
  return *network_name_;
}
inline void ClientMessage_UpdateServer::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_UpdateServer::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_UpdateServer::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_UpdateServer::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_UpdateServer::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_UpdateServer::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port_number = 3;
inline bool ClientMessage_UpdateServer::has_port_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_UpdateServer::set_has_port_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_UpdateServer::clear_has_port_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_UpdateServer::clear_port_number() {
  port_number_ = 0;
  clear_has_port_number();
}
inline ::google::protobuf::int32 ClientMessage_UpdateServer::port_number() const {
  return port_number_;
}
inline void ClientMessage_UpdateServer::set_port_number(::google::protobuf::int32 value) {
  set_has_port_number();
  port_number_ = value;
}

// -------------------------------------------------------------------

// ClientMessage_StopServer

// required string cookie = 1;
inline bool ClientMessage_StopServer::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_StopServer::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_StopServer::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_StopServer::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_StopServer::cookie() const {
  return *cookie_;
}
inline void ClientMessage_StopServer::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_StopServer::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_StopServer::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_StopServer::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_StopServer::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_StopServer::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string network_name = 2;
inline bool ClientMessage_StopServer::has_network_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_StopServer::set_has_network_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_StopServer::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_StopServer::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_StopServer::network_name() const {
  return *network_name_;
}
inline void ClientMessage_StopServer::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_StopServer::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_StopServer::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_StopServer::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_StopServer::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_StopServer::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage_SignKey

// required string cookie = 1;
inline bool ClientMessage_SignKey::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage_SignKey::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage_SignKey::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage_SignKey::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ClientMessage_SignKey::cookie() const {
  return *cookie_;
}
inline void ClientMessage_SignKey::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_SignKey::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ClientMessage_SignKey::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_SignKey::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ClientMessage_SignKey::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_SignKey::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string public_key = 2;
inline bool ClientMessage_SignKey::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage_SignKey::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage_SignKey::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage_SignKey::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& ClientMessage_SignKey::public_key() const {
  return *public_key_;
}
inline void ClientMessage_SignKey::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ClientMessage_SignKey::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ClientMessage_SignKey::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_SignKey::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* ClientMessage_SignKey::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_SignKey::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network_name = 3;
inline bool ClientMessage_SignKey::has_network_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage_SignKey::set_has_network_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage_SignKey::clear_has_network_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage_SignKey::clear_network_name() {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    network_name_->clear();
  }
  clear_has_network_name();
}
inline const ::std::string& ClientMessage_SignKey::network_name() const {
  return *network_name_;
}
inline void ClientMessage_SignKey::set_network_name(const ::std::string& value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_SignKey::set_network_name(const char* value) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(value);
}
inline void ClientMessage_SignKey::set_network_name(const char* value, size_t size) {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  network_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage_SignKey::mutable_network_name() {
  set_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    network_name_ = new ::std::string;
  }
  return network_name_;
}
inline ::std::string* ClientMessage_SignKey::release_network_name() {
  clear_has_network_name();
  if (network_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_name_;
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientMessage_SignKey::set_allocated_network_name(::std::string* network_name) {
  if (network_name_ != &::google::protobuf::internal::kEmptyString) {
    delete network_name_;
  }
  if (network_name) {
    set_has_network_name();
    network_name_ = network_name;
  } else {
    clear_has_network_name();
    network_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientMessage

// required .protocol.ClientMessage.RequestType request = 1;
inline bool ClientMessage::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_request() {
  request_ = 0;
  clear_has_request();
}
inline ::protocol::ClientMessage_RequestType ClientMessage::request() const {
  return static_cast< ::protocol::ClientMessage_RequestType >(request_);
}
inline void ClientMessage::set_request(::protocol::ClientMessage_RequestType value) {
  assert(::protocol::ClientMessage_RequestType_IsValid(value));
  set_has_request();
  request_ = value;
}

// optional .protocol.ClientMessage.Register register_message = 2;
inline bool ClientMessage::has_register_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_register_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_register_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_register_message() {
  if (register_message_ != NULL) register_message_->::protocol::ClientMessage_Register::Clear();
  clear_has_register_message();
}
inline const ::protocol::ClientMessage_Register& ClientMessage::register_message() const {
  return register_message_ != NULL ? *register_message_ : *default_instance_->register_message_;
}
inline ::protocol::ClientMessage_Register* ClientMessage::mutable_register_message() {
  set_has_register_message();
  if (register_message_ == NULL) register_message_ = new ::protocol::ClientMessage_Register;
  return register_message_;
}
inline ::protocol::ClientMessage_Register* ClientMessage::release_register_message() {
  clear_has_register_message();
  ::protocol::ClientMessage_Register* temp = register_message_;
  register_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_register_message(::protocol::ClientMessage_Register* register_message) {
  delete register_message_;
  register_message_ = register_message;
  if (register_message) {
    set_has_register_message();
  } else {
    clear_has_register_message();
  }
}

// optional .protocol.ClientMessage.Unregister unregister_message = 3;
inline bool ClientMessage::has_unregister_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_unregister_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_unregister_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_unregister_message() {
  if (unregister_message_ != NULL) unregister_message_->::protocol::ClientMessage_Unregister::Clear();
  clear_has_unregister_message();
}
inline const ::protocol::ClientMessage_Unregister& ClientMessage::unregister_message() const {
  return unregister_message_ != NULL ? *unregister_message_ : *default_instance_->unregister_message_;
}
inline ::protocol::ClientMessage_Unregister* ClientMessage::mutable_unregister_message() {
  set_has_unregister_message();
  if (unregister_message_ == NULL) unregister_message_ = new ::protocol::ClientMessage_Unregister;
  return unregister_message_;
}
inline ::protocol::ClientMessage_Unregister* ClientMessage::release_unregister_message() {
  clear_has_unregister_message();
  ::protocol::ClientMessage_Unregister* temp = unregister_message_;
  unregister_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_unregister_message(::protocol::ClientMessage_Unregister* unregister_message) {
  delete unregister_message_;
  unregister_message_ = unregister_message;
  if (unregister_message) {
    set_has_unregister_message();
  } else {
    clear_has_unregister_message();
  }
}

// optional .protocol.ClientMessage.Login login_message = 4;
inline bool ClientMessage::has_login_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage::set_has_login_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage::clear_has_login_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage::clear_login_message() {
  if (login_message_ != NULL) login_message_->::protocol::ClientMessage_Login::Clear();
  clear_has_login_message();
}
inline const ::protocol::ClientMessage_Login& ClientMessage::login_message() const {
  return login_message_ != NULL ? *login_message_ : *default_instance_->login_message_;
}
inline ::protocol::ClientMessage_Login* ClientMessage::mutable_login_message() {
  set_has_login_message();
  if (login_message_ == NULL) login_message_ = new ::protocol::ClientMessage_Login;
  return login_message_;
}
inline ::protocol::ClientMessage_Login* ClientMessage::release_login_message() {
  clear_has_login_message();
  ::protocol::ClientMessage_Login* temp = login_message_;
  login_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_login_message(::protocol::ClientMessage_Login* login_message) {
  delete login_message_;
  login_message_ = login_message;
  if (login_message) {
    set_has_login_message();
  } else {
    clear_has_login_message();
  }
}

// optional .protocol.ClientMessage.Logout logout_message = 5;
inline bool ClientMessage::has_logout_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage::set_has_logout_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage::clear_has_logout_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage::clear_logout_message() {
  if (logout_message_ != NULL) logout_message_->::protocol::ClientMessage_Logout::Clear();
  clear_has_logout_message();
}
inline const ::protocol::ClientMessage_Logout& ClientMessage::logout_message() const {
  return logout_message_ != NULL ? *logout_message_ : *default_instance_->logout_message_;
}
inline ::protocol::ClientMessage_Logout* ClientMessage::mutable_logout_message() {
  set_has_logout_message();
  if (logout_message_ == NULL) logout_message_ = new ::protocol::ClientMessage_Logout;
  return logout_message_;
}
inline ::protocol::ClientMessage_Logout* ClientMessage::release_logout_message() {
  clear_has_logout_message();
  ::protocol::ClientMessage_Logout* temp = logout_message_;
  logout_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_logout_message(::protocol::ClientMessage_Logout* logout_message) {
  delete logout_message_;
  logout_message_ = logout_message;
  if (logout_message) {
    set_has_logout_message();
  } else {
    clear_has_logout_message();
  }
}

// optional .protocol.ClientMessage.ListNetworks list_networks_message = 6;
inline bool ClientMessage::has_list_networks_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage::set_has_list_networks_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage::clear_has_list_networks_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage::clear_list_networks_message() {
  if (list_networks_message_ != NULL) list_networks_message_->::protocol::ClientMessage_ListNetworks::Clear();
  clear_has_list_networks_message();
}
inline const ::protocol::ClientMessage_ListNetworks& ClientMessage::list_networks_message() const {
  return list_networks_message_ != NULL ? *list_networks_message_ : *default_instance_->list_networks_message_;
}
inline ::protocol::ClientMessage_ListNetworks* ClientMessage::mutable_list_networks_message() {
  set_has_list_networks_message();
  if (list_networks_message_ == NULL) list_networks_message_ = new ::protocol::ClientMessage_ListNetworks;
  return list_networks_message_;
}
inline ::protocol::ClientMessage_ListNetworks* ClientMessage::release_list_networks_message() {
  clear_has_list_networks_message();
  ::protocol::ClientMessage_ListNetworks* temp = list_networks_message_;
  list_networks_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_list_networks_message(::protocol::ClientMessage_ListNetworks* list_networks_message) {
  delete list_networks_message_;
  list_networks_message_ = list_networks_message;
  if (list_networks_message) {
    set_has_list_networks_message();
  } else {
    clear_has_list_networks_message();
  }
}

// optional .protocol.ClientMessage.ListMyNetworks list_my_networks_message = 7;
inline bool ClientMessage::has_list_my_networks_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientMessage::set_has_list_my_networks_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientMessage::clear_has_list_my_networks_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientMessage::clear_list_my_networks_message() {
  if (list_my_networks_message_ != NULL) list_my_networks_message_->::protocol::ClientMessage_ListMyNetworks::Clear();
  clear_has_list_my_networks_message();
}
inline const ::protocol::ClientMessage_ListMyNetworks& ClientMessage::list_my_networks_message() const {
  return list_my_networks_message_ != NULL ? *list_my_networks_message_ : *default_instance_->list_my_networks_message_;
}
inline ::protocol::ClientMessage_ListMyNetworks* ClientMessage::mutable_list_my_networks_message() {
  set_has_list_my_networks_message();
  if (list_my_networks_message_ == NULL) list_my_networks_message_ = new ::protocol::ClientMessage_ListMyNetworks;
  return list_my_networks_message_;
}
inline ::protocol::ClientMessage_ListMyNetworks* ClientMessage::release_list_my_networks_message() {
  clear_has_list_my_networks_message();
  ::protocol::ClientMessage_ListMyNetworks* temp = list_my_networks_message_;
  list_my_networks_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_list_my_networks_message(::protocol::ClientMessage_ListMyNetworks* list_my_networks_message) {
  delete list_my_networks_message_;
  list_my_networks_message_ = list_my_networks_message;
  if (list_my_networks_message) {
    set_has_list_my_networks_message();
  } else {
    clear_has_list_my_networks_message();
  }
}

// optional .protocol.ClientMessage.ListServers list_servers_message = 8;
inline bool ClientMessage::has_list_servers_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientMessage::set_has_list_servers_message() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientMessage::clear_has_list_servers_message() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientMessage::clear_list_servers_message() {
  if (list_servers_message_ != NULL) list_servers_message_->::protocol::ClientMessage_ListServers::Clear();
  clear_has_list_servers_message();
}
inline const ::protocol::ClientMessage_ListServers& ClientMessage::list_servers_message() const {
  return list_servers_message_ != NULL ? *list_servers_message_ : *default_instance_->list_servers_message_;
}
inline ::protocol::ClientMessage_ListServers* ClientMessage::mutable_list_servers_message() {
  set_has_list_servers_message();
  if (list_servers_message_ == NULL) list_servers_message_ = new ::protocol::ClientMessage_ListServers;
  return list_servers_message_;
}
inline ::protocol::ClientMessage_ListServers* ClientMessage::release_list_servers_message() {
  clear_has_list_servers_message();
  ::protocol::ClientMessage_ListServers* temp = list_servers_message_;
  list_servers_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_list_servers_message(::protocol::ClientMessage_ListServers* list_servers_message) {
  delete list_servers_message_;
  list_servers_message_ = list_servers_message;
  if (list_servers_message) {
    set_has_list_servers_message();
  } else {
    clear_has_list_servers_message();
  }
}

// optional .protocol.ClientMessage.CreateNetwork create_network_message = 9;
inline bool ClientMessage::has_create_network_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientMessage::set_has_create_network_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientMessage::clear_has_create_network_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientMessage::clear_create_network_message() {
  if (create_network_message_ != NULL) create_network_message_->::protocol::ClientMessage_CreateNetwork::Clear();
  clear_has_create_network_message();
}
inline const ::protocol::ClientMessage_CreateNetwork& ClientMessage::create_network_message() const {
  return create_network_message_ != NULL ? *create_network_message_ : *default_instance_->create_network_message_;
}
inline ::protocol::ClientMessage_CreateNetwork* ClientMessage::mutable_create_network_message() {
  set_has_create_network_message();
  if (create_network_message_ == NULL) create_network_message_ = new ::protocol::ClientMessage_CreateNetwork;
  return create_network_message_;
}
inline ::protocol::ClientMessage_CreateNetwork* ClientMessage::release_create_network_message() {
  clear_has_create_network_message();
  ::protocol::ClientMessage_CreateNetwork* temp = create_network_message_;
  create_network_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_create_network_message(::protocol::ClientMessage_CreateNetwork* create_network_message) {
  delete create_network_message_;
  create_network_message_ = create_network_message;
  if (create_network_message) {
    set_has_create_network_message();
  } else {
    clear_has_create_network_message();
  }
}

// optional .protocol.ClientMessage.DeleteNetwork delete_network_message = 10;
inline bool ClientMessage::has_delete_network_message() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientMessage::set_has_delete_network_message() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientMessage::clear_has_delete_network_message() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientMessage::clear_delete_network_message() {
  if (delete_network_message_ != NULL) delete_network_message_->::protocol::ClientMessage_DeleteNetwork::Clear();
  clear_has_delete_network_message();
}
inline const ::protocol::ClientMessage_DeleteNetwork& ClientMessage::delete_network_message() const {
  return delete_network_message_ != NULL ? *delete_network_message_ : *default_instance_->delete_network_message_;
}
inline ::protocol::ClientMessage_DeleteNetwork* ClientMessage::mutable_delete_network_message() {
  set_has_delete_network_message();
  if (delete_network_message_ == NULL) delete_network_message_ = new ::protocol::ClientMessage_DeleteNetwork;
  return delete_network_message_;
}
inline ::protocol::ClientMessage_DeleteNetwork* ClientMessage::release_delete_network_message() {
  clear_has_delete_network_message();
  ::protocol::ClientMessage_DeleteNetwork* temp = delete_network_message_;
  delete_network_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_delete_network_message(::protocol::ClientMessage_DeleteNetwork* delete_network_message) {
  delete delete_network_message_;
  delete_network_message_ = delete_network_message;
  if (delete_network_message) {
    set_has_delete_network_message();
  } else {
    clear_has_delete_network_message();
  }
}

// optional .protocol.ClientMessage.InviteUser invite_user_message = 11;
inline bool ClientMessage::has_invite_user_message() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientMessage::set_has_invite_user_message() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientMessage::clear_has_invite_user_message() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientMessage::clear_invite_user_message() {
  if (invite_user_message_ != NULL) invite_user_message_->::protocol::ClientMessage_InviteUser::Clear();
  clear_has_invite_user_message();
}
inline const ::protocol::ClientMessage_InviteUser& ClientMessage::invite_user_message() const {
  return invite_user_message_ != NULL ? *invite_user_message_ : *default_instance_->invite_user_message_;
}
inline ::protocol::ClientMessage_InviteUser* ClientMessage::mutable_invite_user_message() {
  set_has_invite_user_message();
  if (invite_user_message_ == NULL) invite_user_message_ = new ::protocol::ClientMessage_InviteUser;
  return invite_user_message_;
}
inline ::protocol::ClientMessage_InviteUser* ClientMessage::release_invite_user_message() {
  clear_has_invite_user_message();
  ::protocol::ClientMessage_InviteUser* temp = invite_user_message_;
  invite_user_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_invite_user_message(::protocol::ClientMessage_InviteUser* invite_user_message) {
  delete invite_user_message_;
  invite_user_message_ = invite_user_message;
  if (invite_user_message) {
    set_has_invite_user_message();
  } else {
    clear_has_invite_user_message();
  }
}

// optional .protocol.ClientMessage.RemoveUser remove_user_message = 12;
inline bool ClientMessage::has_remove_user_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientMessage::set_has_remove_user_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientMessage::clear_has_remove_user_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientMessage::clear_remove_user_message() {
  if (remove_user_message_ != NULL) remove_user_message_->::protocol::ClientMessage_RemoveUser::Clear();
  clear_has_remove_user_message();
}
inline const ::protocol::ClientMessage_RemoveUser& ClientMessage::remove_user_message() const {
  return remove_user_message_ != NULL ? *remove_user_message_ : *default_instance_->remove_user_message_;
}
inline ::protocol::ClientMessage_RemoveUser* ClientMessage::mutable_remove_user_message() {
  set_has_remove_user_message();
  if (remove_user_message_ == NULL) remove_user_message_ = new ::protocol::ClientMessage_RemoveUser;
  return remove_user_message_;
}
inline ::protocol::ClientMessage_RemoveUser* ClientMessage::release_remove_user_message() {
  clear_has_remove_user_message();
  ::protocol::ClientMessage_RemoveUser* temp = remove_user_message_;
  remove_user_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_remove_user_message(::protocol::ClientMessage_RemoveUser* remove_user_message) {
  delete remove_user_message_;
  remove_user_message_ = remove_user_message;
  if (remove_user_message) {
    set_has_remove_user_message();
  } else {
    clear_has_remove_user_message();
  }
}

// optional .protocol.ClientMessage.UserInfo user_info_message = 13;
inline bool ClientMessage::has_user_info_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientMessage::set_has_user_info_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientMessage::clear_has_user_info_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientMessage::clear_user_info_message() {
  if (user_info_message_ != NULL) user_info_message_->::protocol::ClientMessage_UserInfo::Clear();
  clear_has_user_info_message();
}
inline const ::protocol::ClientMessage_UserInfo& ClientMessage::user_info_message() const {
  return user_info_message_ != NULL ? *user_info_message_ : *default_instance_->user_info_message_;
}
inline ::protocol::ClientMessage_UserInfo* ClientMessage::mutable_user_info_message() {
  set_has_user_info_message();
  if (user_info_message_ == NULL) user_info_message_ = new ::protocol::ClientMessage_UserInfo;
  return user_info_message_;
}
inline ::protocol::ClientMessage_UserInfo* ClientMessage::release_user_info_message() {
  clear_has_user_info_message();
  ::protocol::ClientMessage_UserInfo* temp = user_info_message_;
  user_info_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_user_info_message(::protocol::ClientMessage_UserInfo* user_info_message) {
  delete user_info_message_;
  user_info_message_ = user_info_message;
  if (user_info_message) {
    set_has_user_info_message();
  } else {
    clear_has_user_info_message();
  }
}

// optional .protocol.ClientMessage.UpdateServer update_server_message = 14;
inline bool ClientMessage::has_update_server_message() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClientMessage::set_has_update_server_message() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClientMessage::clear_has_update_server_message() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClientMessage::clear_update_server_message() {
  if (update_server_message_ != NULL) update_server_message_->::protocol::ClientMessage_UpdateServer::Clear();
  clear_has_update_server_message();
}
inline const ::protocol::ClientMessage_UpdateServer& ClientMessage::update_server_message() const {
  return update_server_message_ != NULL ? *update_server_message_ : *default_instance_->update_server_message_;
}
inline ::protocol::ClientMessage_UpdateServer* ClientMessage::mutable_update_server_message() {
  set_has_update_server_message();
  if (update_server_message_ == NULL) update_server_message_ = new ::protocol::ClientMessage_UpdateServer;
  return update_server_message_;
}
inline ::protocol::ClientMessage_UpdateServer* ClientMessage::release_update_server_message() {
  clear_has_update_server_message();
  ::protocol::ClientMessage_UpdateServer* temp = update_server_message_;
  update_server_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_update_server_message(::protocol::ClientMessage_UpdateServer* update_server_message) {
  delete update_server_message_;
  update_server_message_ = update_server_message;
  if (update_server_message) {
    set_has_update_server_message();
  } else {
    clear_has_update_server_message();
  }
}

// optional .protocol.ClientMessage.StopServer stop_server_message = 15;
inline bool ClientMessage::has_stop_server_message() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ClientMessage::set_has_stop_server_message() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ClientMessage::clear_has_stop_server_message() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ClientMessage::clear_stop_server_message() {
  if (stop_server_message_ != NULL) stop_server_message_->::protocol::ClientMessage_StopServer::Clear();
  clear_has_stop_server_message();
}
inline const ::protocol::ClientMessage_StopServer& ClientMessage::stop_server_message() const {
  return stop_server_message_ != NULL ? *stop_server_message_ : *default_instance_->stop_server_message_;
}
inline ::protocol::ClientMessage_StopServer* ClientMessage::mutable_stop_server_message() {
  set_has_stop_server_message();
  if (stop_server_message_ == NULL) stop_server_message_ = new ::protocol::ClientMessage_StopServer;
  return stop_server_message_;
}
inline ::protocol::ClientMessage_StopServer* ClientMessage::release_stop_server_message() {
  clear_has_stop_server_message();
  ::protocol::ClientMessage_StopServer* temp = stop_server_message_;
  stop_server_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_stop_server_message(::protocol::ClientMessage_StopServer* stop_server_message) {
  delete stop_server_message_;
  stop_server_message_ = stop_server_message;
  if (stop_server_message) {
    set_has_stop_server_message();
  } else {
    clear_has_stop_server_message();
  }
}

// optional .protocol.ClientMessage.SignKey sign_key_message = 16;
inline bool ClientMessage::has_sign_key_message() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ClientMessage::set_has_sign_key_message() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ClientMessage::clear_has_sign_key_message() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ClientMessage::clear_sign_key_message() {
  if (sign_key_message_ != NULL) sign_key_message_->::protocol::ClientMessage_SignKey::Clear();
  clear_has_sign_key_message();
}
inline const ::protocol::ClientMessage_SignKey& ClientMessage::sign_key_message() const {
  return sign_key_message_ != NULL ? *sign_key_message_ : *default_instance_->sign_key_message_;
}
inline ::protocol::ClientMessage_SignKey* ClientMessage::mutable_sign_key_message() {
  set_has_sign_key_message();
  if (sign_key_message_ == NULL) sign_key_message_ = new ::protocol::ClientMessage_SignKey;
  return sign_key_message_;
}
inline ::protocol::ClientMessage_SignKey* ClientMessage::release_sign_key_message() {
  clear_has_sign_key_message();
  ::protocol::ClientMessage_SignKey* temp = sign_key_message_;
  sign_key_message_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_sign_key_message(::protocol::ClientMessage_SignKey* sign_key_message) {
  delete sign_key_message_;
  sign_key_message_ = sign_key_message;
  if (sign_key_message) {
    set_has_sign_key_message();
  } else {
    clear_has_sign_key_message();
  }
}

// -------------------------------------------------------------------

// NodeMessage_Register

// required string user_certificate = 1;
inline bool NodeMessage_Register::has_user_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_Register::set_has_user_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_Register::clear_has_user_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_Register::clear_user_certificate() {
  if (user_certificate_ != &::google::protobuf::internal::kEmptyString) {
    user_certificate_->clear();
  }
  clear_has_user_certificate();
}
inline const ::std::string& NodeMessage_Register::user_certificate() const {
  return *user_certificate_;
}
inline void NodeMessage_Register::set_user_certificate(const ::std::string& value) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(value);
}
inline void NodeMessage_Register::set_user_certificate(const char* value) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(value);
}
inline void NodeMessage_Register::set_user_certificate(const char* value, size_t size) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_Register::mutable_user_certificate() {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  return user_certificate_;
}
inline ::std::string* NodeMessage_Register::release_user_certificate() {
  clear_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_certificate_;
    user_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_Register::set_allocated_user_certificate(::std::string* user_certificate) {
  if (user_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete user_certificate_;
  }
  if (user_certificate) {
    set_has_user_certificate();
    user_certificate_ = user_certificate;
  } else {
    clear_has_user_certificate();
    user_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string node_certificate = 2;
inline bool NodeMessage_Register::has_node_certificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMessage_Register::set_has_node_certificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMessage_Register::clear_has_node_certificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMessage_Register::clear_node_certificate() {
  if (node_certificate_ != &::google::protobuf::internal::kEmptyString) {
    node_certificate_->clear();
  }
  clear_has_node_certificate();
}
inline const ::std::string& NodeMessage_Register::node_certificate() const {
  return *node_certificate_;
}
inline void NodeMessage_Register::set_node_certificate(const ::std::string& value) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(value);
}
inline void NodeMessage_Register::set_node_certificate(const char* value) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(value);
}
inline void NodeMessage_Register::set_node_certificate(const char* value, size_t size) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_Register::mutable_node_certificate() {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  return node_certificate_;
}
inline ::std::string* NodeMessage_Register::release_node_certificate() {
  clear_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_certificate_;
    node_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_Register::set_allocated_node_certificate(::std::string* node_certificate) {
  if (node_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete node_certificate_;
  }
  if (node_certificate) {
    set_has_node_certificate();
    node_certificate_ = node_certificate;
  } else {
    clear_has_node_certificate();
    node_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeMessage_Login

// required string cookie = 1;
inline bool NodeMessage_Login::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_Login::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_Login::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_Login::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& NodeMessage_Login::cookie() const {
  return *cookie_;
}
inline void NodeMessage_Login::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void NodeMessage_Login::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void NodeMessage_Login::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_Login::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* NodeMessage_Login::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_Login::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string node_certificate = 2;
inline bool NodeMessage_Login::has_node_certificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMessage_Login::set_has_node_certificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMessage_Login::clear_has_node_certificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMessage_Login::clear_node_certificate() {
  if (node_certificate_ != &::google::protobuf::internal::kEmptyString) {
    node_certificate_->clear();
  }
  clear_has_node_certificate();
}
inline const ::std::string& NodeMessage_Login::node_certificate() const {
  return *node_certificate_;
}
inline void NodeMessage_Login::set_node_certificate(const ::std::string& value) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(value);
}
inline void NodeMessage_Login::set_node_certificate(const char* value) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(value);
}
inline void NodeMessage_Login::set_node_certificate(const char* value, size_t size) {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  node_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_Login::mutable_node_certificate() {
  set_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    node_certificate_ = new ::std::string;
  }
  return node_certificate_;
}
inline ::std::string* NodeMessage_Login::release_node_certificate() {
  clear_has_node_certificate();
  if (node_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_certificate_;
    node_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_Login::set_allocated_node_certificate(::std::string* node_certificate) {
  if (node_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete node_certificate_;
  }
  if (node_certificate) {
    set_has_node_certificate();
    node_certificate_ = node_certificate;
  } else {
    clear_has_node_certificate();
    node_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeMessage_ListNetworks_Network

// required string name = 1;
inline bool NodeMessage_ListNetworks_Network::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_ListNetworks_Network::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NodeMessage_ListNetworks_Network::name() const {
  return *name_;
}
inline void NodeMessage_ListNetworks_Network::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListNetworks_Network::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NodeMessage_ListNetworks_Network::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListNetworks_Network::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string creator_name = 2;
inline bool NodeMessage_ListNetworks_Network::has_creator_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_creator_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_creator_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMessage_ListNetworks_Network::clear_creator_name() {
  if (creator_name_ != &::google::protobuf::internal::kEmptyString) {
    creator_name_->clear();
  }
  clear_has_creator_name();
}
inline const ::std::string& NodeMessage_ListNetworks_Network::creator_name() const {
  return *creator_name_;
}
inline void NodeMessage_ListNetworks_Network::set_creator_name(const ::std::string& value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_creator_name(const char* value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_creator_name(const char* value, size_t size) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListNetworks_Network::mutable_creator_name() {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  return creator_name_;
}
inline ::std::string* NodeMessage_ListNetworks_Network::release_creator_name() {
  clear_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_name_;
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListNetworks_Network::set_allocated_creator_name(::std::string* creator_name) {
  if (creator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_name_;
  }
  if (creator_name) {
    set_has_creator_name();
    creator_name_ = creator_name;
  } else {
    clear_has_creator_name();
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string creator_email = 3;
inline bool NodeMessage_ListNetworks_Network::has_creator_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_creator_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_creator_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeMessage_ListNetworks_Network::clear_creator_email() {
  if (creator_email_ != &::google::protobuf::internal::kEmptyString) {
    creator_email_->clear();
  }
  clear_has_creator_email();
}
inline const ::std::string& NodeMessage_ListNetworks_Network::creator_email() const {
  return *creator_email_;
}
inline void NodeMessage_ListNetworks_Network::set_creator_email(const ::std::string& value) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_creator_email(const char* value) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_creator_email(const char* value, size_t size) {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  creator_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListNetworks_Network::mutable_creator_email() {
  set_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    creator_email_ = new ::std::string;
  }
  return creator_email_;
}
inline ::std::string* NodeMessage_ListNetworks_Network::release_creator_email() {
  clear_has_creator_email();
  if (creator_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_email_;
    creator_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListNetworks_Network::set_allocated_creator_email(::std::string* creator_email) {
  if (creator_email_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_email_;
  }
  if (creator_email) {
    set_has_creator_email();
    creator_email_ = creator_email;
  } else {
    clear_has_creator_email();
    creator_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protocol.ClientMessage.CreateNetwork.AccessRights access_rights = 4;
inline bool NodeMessage_ListNetworks_Network::has_access_rights() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_access_rights() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_access_rights() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeMessage_ListNetworks_Network::clear_access_rights() {
  access_rights_ = 1;
  clear_has_access_rights();
}
inline ::protocol::ClientMessage_CreateNetwork_AccessRights NodeMessage_ListNetworks_Network::access_rights() const {
  return static_cast< ::protocol::ClientMessage_CreateNetwork_AccessRights >(access_rights_);
}
inline void NodeMessage_ListNetworks_Network::set_access_rights(::protocol::ClientMessage_CreateNetwork_AccessRights value) {
  assert(::protocol::ClientMessage_CreateNetwork_AccessRights_IsValid(value));
  set_has_access_rights();
  access_rights_ = value;
}

// required .protocol.ClientMessage.CreateNetwork.ParticipationRights participation_rights = 5;
inline bool NodeMessage_ListNetworks_Network::has_participation_rights() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_participation_rights() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_participation_rights() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeMessage_ListNetworks_Network::clear_participation_rights() {
  participation_rights_ = 5;
  clear_has_participation_rights();
}
inline ::protocol::ClientMessage_CreateNetwork_ParticipationRights NodeMessage_ListNetworks_Network::participation_rights() const {
  return static_cast< ::protocol::ClientMessage_CreateNetwork_ParticipationRights >(participation_rights_);
}
inline void NodeMessage_ListNetworks_Network::set_participation_rights(::protocol::ClientMessage_CreateNetwork_ParticipationRights value) {
  assert(::protocol::ClientMessage_CreateNetwork_ParticipationRights_IsValid(value));
  set_has_participation_rights();
  participation_rights_ = value;
}

// optional string protocol_name = 6;
inline bool NodeMessage_ListNetworks_Network::has_protocol_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeMessage_ListNetworks_Network::set_has_protocol_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeMessage_ListNetworks_Network::clear_has_protocol_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeMessage_ListNetworks_Network::clear_protocol_name() {
  if (protocol_name_ != &::google::protobuf::internal::kEmptyString) {
    protocol_name_->clear();
  }
  clear_has_protocol_name();
}
inline const ::std::string& NodeMessage_ListNetworks_Network::protocol_name() const {
  return *protocol_name_;
}
inline void NodeMessage_ListNetworks_Network::set_protocol_name(const ::std::string& value) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_protocol_name(const char* value) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(value);
}
inline void NodeMessage_ListNetworks_Network::set_protocol_name(const char* value, size_t size) {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  protocol_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListNetworks_Network::mutable_protocol_name() {
  set_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    protocol_name_ = new ::std::string;
  }
  return protocol_name_;
}
inline ::std::string* NodeMessage_ListNetworks_Network::release_protocol_name() {
  clear_has_protocol_name();
  if (protocol_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_name_;
    protocol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListNetworks_Network::set_allocated_protocol_name(::std::string* protocol_name) {
  if (protocol_name_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_name_;
  }
  if (protocol_name) {
    set_has_protocol_name();
    protocol_name_ = protocol_name;
  } else {
    clear_has_protocol_name();
    protocol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeMessage_ListNetworks

// repeated .protocol.NodeMessage.ListNetworks.Network network_list = 1;
inline int NodeMessage_ListNetworks::network_list_size() const {
  return network_list_.size();
}
inline void NodeMessage_ListNetworks::clear_network_list() {
  network_list_.Clear();
}
inline const ::protocol::NodeMessage_ListNetworks_Network& NodeMessage_ListNetworks::network_list(int index) const {
  return network_list_.Get(index);
}
inline ::protocol::NodeMessage_ListNetworks_Network* NodeMessage_ListNetworks::mutable_network_list(int index) {
  return network_list_.Mutable(index);
}
inline ::protocol::NodeMessage_ListNetworks_Network* NodeMessage_ListNetworks::add_network_list() {
  return network_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >&
NodeMessage_ListNetworks::network_list() const {
  return network_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >*
NodeMessage_ListNetworks::mutable_network_list() {
  return &network_list_;
}

// -------------------------------------------------------------------

// NodeMessage_ListMyNetworks

// repeated .protocol.NodeMessage.ListNetworks.Network network_list = 1;
inline int NodeMessage_ListMyNetworks::network_list_size() const {
  return network_list_.size();
}
inline void NodeMessage_ListMyNetworks::clear_network_list() {
  network_list_.Clear();
}
inline const ::protocol::NodeMessage_ListNetworks_Network& NodeMessage_ListMyNetworks::network_list(int index) const {
  return network_list_.Get(index);
}
inline ::protocol::NodeMessage_ListNetworks_Network* NodeMessage_ListMyNetworks::mutable_network_list(int index) {
  return network_list_.Mutable(index);
}
inline ::protocol::NodeMessage_ListNetworks_Network* NodeMessage_ListMyNetworks::add_network_list() {
  return network_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >&
NodeMessage_ListMyNetworks::network_list() const {
  return network_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListNetworks_Network >*
NodeMessage_ListMyNetworks::mutable_network_list() {
  return &network_list_;
}

// -------------------------------------------------------------------

// NodeMessage_ListServers_Server

// required string username = 1;
inline bool NodeMessage_ListServers_Server::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_ListServers_Server::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_ListServers_Server::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_ListServers_Server::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& NodeMessage_ListServers_Server::username() const {
  return *username_;
}
inline void NodeMessage_ListServers_Server::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NodeMessage_ListServers_Server::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NodeMessage_ListServers_Server::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListServers_Server::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* NodeMessage_ListServers_Server::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListServers_Server::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip_address = 2;
inline bool NodeMessage_ListServers_Server::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMessage_ListServers_Server::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMessage_ListServers_Server::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMessage_ListServers_Server::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& NodeMessage_ListServers_Server::ip_address() const {
  return *ip_address_;
}
inline void NodeMessage_ListServers_Server::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void NodeMessage_ListServers_Server::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void NodeMessage_ListServers_Server::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_ListServers_Server::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  return ip_address_;
}
inline ::std::string* NodeMessage_ListServers_Server::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_ListServers_Server::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port_number = 3;
inline bool NodeMessage_ListServers_Server::has_port_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeMessage_ListServers_Server::set_has_port_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeMessage_ListServers_Server::clear_has_port_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeMessage_ListServers_Server::clear_port_number() {
  port_number_ = 0;
  clear_has_port_number();
}
inline ::google::protobuf::int32 NodeMessage_ListServers_Server::port_number() const {
  return port_number_;
}
inline void NodeMessage_ListServers_Server::set_port_number(::google::protobuf::int32 value) {
  set_has_port_number();
  port_number_ = value;
}

// -------------------------------------------------------------------

// NodeMessage_ListServers

// repeated .protocol.NodeMessage.ListServers list_servers = 1;
inline int NodeMessage_ListServers::list_servers_size() const {
  return list_servers_.size();
}
inline void NodeMessage_ListServers::clear_list_servers() {
  list_servers_.Clear();
}
inline const ::protocol::NodeMessage_ListServers& NodeMessage_ListServers::list_servers(int index) const {
  return list_servers_.Get(index);
}
inline ::protocol::NodeMessage_ListServers* NodeMessage_ListServers::mutable_list_servers(int index) {
  return list_servers_.Mutable(index);
}
inline ::protocol::NodeMessage_ListServers* NodeMessage_ListServers::add_list_servers() {
  return list_servers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListServers >&
NodeMessage_ListServers::list_servers() const {
  return list_servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeMessage_ListServers >*
NodeMessage_ListServers::mutable_list_servers() {
  return &list_servers_;
}

// -------------------------------------------------------------------

// NodeMessage_UserInfo

// required string user_public_key = 1;
inline bool NodeMessage_UserInfo::has_user_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_UserInfo::set_has_user_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_UserInfo::clear_has_user_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_UserInfo::clear_user_public_key() {
  if (user_public_key_ != &::google::protobuf::internal::kEmptyString) {
    user_public_key_->clear();
  }
  clear_has_user_public_key();
}
inline const ::std::string& NodeMessage_UserInfo::user_public_key() const {
  return *user_public_key_;
}
inline void NodeMessage_UserInfo::set_user_public_key(const ::std::string& value) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::kEmptyString) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(value);
}
inline void NodeMessage_UserInfo::set_user_public_key(const char* value) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::kEmptyString) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(value);
}
inline void NodeMessage_UserInfo::set_user_public_key(const char* value, size_t size) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::kEmptyString) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_UserInfo::mutable_user_public_key() {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::kEmptyString) {
    user_public_key_ = new ::std::string;
  }
  return user_public_key_;
}
inline ::std::string* NodeMessage_UserInfo::release_user_public_key() {
  clear_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_public_key_;
    user_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_UserInfo::set_allocated_user_public_key(::std::string* user_public_key) {
  if (user_public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete user_public_key_;
  }
  if (user_public_key) {
    set_has_user_public_key();
    user_public_key_ = user_public_key;
  } else {
    clear_has_user_public_key();
    user_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeMessage_UpdateServer

// required int32 seconds_to_update = 1;
inline bool NodeMessage_UpdateServer::has_seconds_to_update() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_UpdateServer::set_has_seconds_to_update() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_UpdateServer::clear_has_seconds_to_update() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_UpdateServer::clear_seconds_to_update() {
  seconds_to_update_ = 0;
  clear_has_seconds_to_update();
}
inline ::google::protobuf::int32 NodeMessage_UpdateServer::seconds_to_update() const {
  return seconds_to_update_;
}
inline void NodeMessage_UpdateServer::set_seconds_to_update(::google::protobuf::int32 value) {
  set_has_seconds_to_update();
  seconds_to_update_ = value;
}

// -------------------------------------------------------------------

// NodeMessage_SignKey

// required string user_certificate = 1;
inline bool NodeMessage_SignKey::has_user_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage_SignKey::set_has_user_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage_SignKey::clear_has_user_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage_SignKey::clear_user_certificate() {
  if (user_certificate_ != &::google::protobuf::internal::kEmptyString) {
    user_certificate_->clear();
  }
  clear_has_user_certificate();
}
inline const ::std::string& NodeMessage_SignKey::user_certificate() const {
  return *user_certificate_;
}
inline void NodeMessage_SignKey::set_user_certificate(const ::std::string& value) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(value);
}
inline void NodeMessage_SignKey::set_user_certificate(const char* value) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(value);
}
inline void NodeMessage_SignKey::set_user_certificate(const char* value, size_t size) {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  user_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeMessage_SignKey::mutable_user_certificate() {
  set_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    user_certificate_ = new ::std::string;
  }
  return user_certificate_;
}
inline ::std::string* NodeMessage_SignKey::release_user_certificate() {
  clear_has_user_certificate();
  if (user_certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_certificate_;
    user_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeMessage_SignKey::set_allocated_user_certificate(::std::string* user_certificate) {
  if (user_certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete user_certificate_;
  }
  if (user_certificate) {
    set_has_user_certificate();
    user_certificate_ = user_certificate;
  } else {
    clear_has_user_certificate();
    user_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeMessage

// required .protocol.NodeMessage.ResponseType response_type = 1;
inline bool NodeMessage::has_response_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMessage::set_has_response_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMessage::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMessage::clear_response_type() {
  response_type_ = 200;
  clear_has_response_type();
}
inline ::protocol::NodeMessage_ResponseType NodeMessage::response_type() const {
  return static_cast< ::protocol::NodeMessage_ResponseType >(response_type_);
}
inline void NodeMessage::set_response_type(::protocol::NodeMessage_ResponseType value) {
  assert(::protocol::NodeMessage_ResponseType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
}

// optional .protocol.NodeMessage.Register register_response = 2;
inline bool NodeMessage::has_register_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMessage::set_has_register_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMessage::clear_has_register_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMessage::clear_register_response() {
  if (register_response_ != NULL) register_response_->::protocol::NodeMessage_Register::Clear();
  clear_has_register_response();
}
inline const ::protocol::NodeMessage_Register& NodeMessage::register_response() const {
  return register_response_ != NULL ? *register_response_ : *default_instance_->register_response_;
}
inline ::protocol::NodeMessage_Register* NodeMessage::mutable_register_response() {
  set_has_register_response();
  if (register_response_ == NULL) register_response_ = new ::protocol::NodeMessage_Register;
  return register_response_;
}
inline ::protocol::NodeMessage_Register* NodeMessage::release_register_response() {
  clear_has_register_response();
  ::protocol::NodeMessage_Register* temp = register_response_;
  register_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_register_response(::protocol::NodeMessage_Register* register_response) {
  delete register_response_;
  register_response_ = register_response;
  if (register_response) {
    set_has_register_response();
  } else {
    clear_has_register_response();
  }
}

// optional .protocol.NodeMessage.Login login_response = 3;
inline bool NodeMessage::has_login_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeMessage::set_has_login_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeMessage::clear_has_login_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeMessage::clear_login_response() {
  if (login_response_ != NULL) login_response_->::protocol::NodeMessage_Login::Clear();
  clear_has_login_response();
}
inline const ::protocol::NodeMessage_Login& NodeMessage::login_response() const {
  return login_response_ != NULL ? *login_response_ : *default_instance_->login_response_;
}
inline ::protocol::NodeMessage_Login* NodeMessage::mutable_login_response() {
  set_has_login_response();
  if (login_response_ == NULL) login_response_ = new ::protocol::NodeMessage_Login;
  return login_response_;
}
inline ::protocol::NodeMessage_Login* NodeMessage::release_login_response() {
  clear_has_login_response();
  ::protocol::NodeMessage_Login* temp = login_response_;
  login_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_login_response(::protocol::NodeMessage_Login* login_response) {
  delete login_response_;
  login_response_ = login_response;
  if (login_response) {
    set_has_login_response();
  } else {
    clear_has_login_response();
  }
}

// optional .protocol.NodeMessage.ListNetworks list_networks_response = 5;
inline bool NodeMessage::has_list_networks_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeMessage::set_has_list_networks_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeMessage::clear_has_list_networks_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeMessage::clear_list_networks_response() {
  if (list_networks_response_ != NULL) list_networks_response_->::protocol::NodeMessage_ListNetworks::Clear();
  clear_has_list_networks_response();
}
inline const ::protocol::NodeMessage_ListNetworks& NodeMessage::list_networks_response() const {
  return list_networks_response_ != NULL ? *list_networks_response_ : *default_instance_->list_networks_response_;
}
inline ::protocol::NodeMessage_ListNetworks* NodeMessage::mutable_list_networks_response() {
  set_has_list_networks_response();
  if (list_networks_response_ == NULL) list_networks_response_ = new ::protocol::NodeMessage_ListNetworks;
  return list_networks_response_;
}
inline ::protocol::NodeMessage_ListNetworks* NodeMessage::release_list_networks_response() {
  clear_has_list_networks_response();
  ::protocol::NodeMessage_ListNetworks* temp = list_networks_response_;
  list_networks_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_list_networks_response(::protocol::NodeMessage_ListNetworks* list_networks_response) {
  delete list_networks_response_;
  list_networks_response_ = list_networks_response;
  if (list_networks_response) {
    set_has_list_networks_response();
  } else {
    clear_has_list_networks_response();
  }
}

// optional .protocol.NodeMessage.ListMyNetworks list_my_networks_response = 6;
inline bool NodeMessage::has_list_my_networks_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeMessage::set_has_list_my_networks_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeMessage::clear_has_list_my_networks_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeMessage::clear_list_my_networks_response() {
  if (list_my_networks_response_ != NULL) list_my_networks_response_->::protocol::NodeMessage_ListMyNetworks::Clear();
  clear_has_list_my_networks_response();
}
inline const ::protocol::NodeMessage_ListMyNetworks& NodeMessage::list_my_networks_response() const {
  return list_my_networks_response_ != NULL ? *list_my_networks_response_ : *default_instance_->list_my_networks_response_;
}
inline ::protocol::NodeMessage_ListMyNetworks* NodeMessage::mutable_list_my_networks_response() {
  set_has_list_my_networks_response();
  if (list_my_networks_response_ == NULL) list_my_networks_response_ = new ::protocol::NodeMessage_ListMyNetworks;
  return list_my_networks_response_;
}
inline ::protocol::NodeMessage_ListMyNetworks* NodeMessage::release_list_my_networks_response() {
  clear_has_list_my_networks_response();
  ::protocol::NodeMessage_ListMyNetworks* temp = list_my_networks_response_;
  list_my_networks_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_list_my_networks_response(::protocol::NodeMessage_ListMyNetworks* list_my_networks_response) {
  delete list_my_networks_response_;
  list_my_networks_response_ = list_my_networks_response;
  if (list_my_networks_response) {
    set_has_list_my_networks_response();
  } else {
    clear_has_list_my_networks_response();
  }
}

// optional .protocol.NodeMessage.ListServers list_servers_response = 7;
inline bool NodeMessage::has_list_servers_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeMessage::set_has_list_servers_response() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeMessage::clear_has_list_servers_response() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeMessage::clear_list_servers_response() {
  if (list_servers_response_ != NULL) list_servers_response_->::protocol::NodeMessage_ListServers::Clear();
  clear_has_list_servers_response();
}
inline const ::protocol::NodeMessage_ListServers& NodeMessage::list_servers_response() const {
  return list_servers_response_ != NULL ? *list_servers_response_ : *default_instance_->list_servers_response_;
}
inline ::protocol::NodeMessage_ListServers* NodeMessage::mutable_list_servers_response() {
  set_has_list_servers_response();
  if (list_servers_response_ == NULL) list_servers_response_ = new ::protocol::NodeMessage_ListServers;
  return list_servers_response_;
}
inline ::protocol::NodeMessage_ListServers* NodeMessage::release_list_servers_response() {
  clear_has_list_servers_response();
  ::protocol::NodeMessage_ListServers* temp = list_servers_response_;
  list_servers_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_list_servers_response(::protocol::NodeMessage_ListServers* list_servers_response) {
  delete list_servers_response_;
  list_servers_response_ = list_servers_response;
  if (list_servers_response) {
    set_has_list_servers_response();
  } else {
    clear_has_list_servers_response();
  }
}

// optional .protocol.NodeMessage.UserInfo user_info_response = 13;
inline bool NodeMessage::has_user_info_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeMessage::set_has_user_info_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeMessage::clear_has_user_info_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeMessage::clear_user_info_response() {
  if (user_info_response_ != NULL) user_info_response_->::protocol::NodeMessage_UserInfo::Clear();
  clear_has_user_info_response();
}
inline const ::protocol::NodeMessage_UserInfo& NodeMessage::user_info_response() const {
  return user_info_response_ != NULL ? *user_info_response_ : *default_instance_->user_info_response_;
}
inline ::protocol::NodeMessage_UserInfo* NodeMessage::mutable_user_info_response() {
  set_has_user_info_response();
  if (user_info_response_ == NULL) user_info_response_ = new ::protocol::NodeMessage_UserInfo;
  return user_info_response_;
}
inline ::protocol::NodeMessage_UserInfo* NodeMessage::release_user_info_response() {
  clear_has_user_info_response();
  ::protocol::NodeMessage_UserInfo* temp = user_info_response_;
  user_info_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_user_info_response(::protocol::NodeMessage_UserInfo* user_info_response) {
  delete user_info_response_;
  user_info_response_ = user_info_response;
  if (user_info_response) {
    set_has_user_info_response();
  } else {
    clear_has_user_info_response();
  }
}

// optional .protocol.NodeMessage.UpdateServer update_server_response = 14;
inline bool NodeMessage::has_update_server_response() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeMessage::set_has_update_server_response() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeMessage::clear_has_update_server_response() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeMessage::clear_update_server_response() {
  if (update_server_response_ != NULL) update_server_response_->::protocol::NodeMessage_UpdateServer::Clear();
  clear_has_update_server_response();
}
inline const ::protocol::NodeMessage_UpdateServer& NodeMessage::update_server_response() const {
  return update_server_response_ != NULL ? *update_server_response_ : *default_instance_->update_server_response_;
}
inline ::protocol::NodeMessage_UpdateServer* NodeMessage::mutable_update_server_response() {
  set_has_update_server_response();
  if (update_server_response_ == NULL) update_server_response_ = new ::protocol::NodeMessage_UpdateServer;
  return update_server_response_;
}
inline ::protocol::NodeMessage_UpdateServer* NodeMessage::release_update_server_response() {
  clear_has_update_server_response();
  ::protocol::NodeMessage_UpdateServer* temp = update_server_response_;
  update_server_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_update_server_response(::protocol::NodeMessage_UpdateServer* update_server_response) {
  delete update_server_response_;
  update_server_response_ = update_server_response;
  if (update_server_response) {
    set_has_update_server_response();
  } else {
    clear_has_update_server_response();
  }
}

// optional .protocol.NodeMessage.SignKey sign_key_response = 16;
inline bool NodeMessage::has_sign_key_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeMessage::set_has_sign_key_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeMessage::clear_has_sign_key_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeMessage::clear_sign_key_response() {
  if (sign_key_response_ != NULL) sign_key_response_->::protocol::NodeMessage_SignKey::Clear();
  clear_has_sign_key_response();
}
inline const ::protocol::NodeMessage_SignKey& NodeMessage::sign_key_response() const {
  return sign_key_response_ != NULL ? *sign_key_response_ : *default_instance_->sign_key_response_;
}
inline ::protocol::NodeMessage_SignKey* NodeMessage::mutable_sign_key_response() {
  set_has_sign_key_response();
  if (sign_key_response_ == NULL) sign_key_response_ = new ::protocol::NodeMessage_SignKey;
  return sign_key_response_;
}
inline ::protocol::NodeMessage_SignKey* NodeMessage::release_sign_key_response() {
  clear_has_sign_key_response();
  ::protocol::NodeMessage_SignKey* temp = sign_key_response_;
  sign_key_response_ = NULL;
  return temp;
}
inline void NodeMessage::set_allocated_sign_key_response(::protocol::NodeMessage_SignKey* sign_key_response) {
  delete sign_key_response_;
  sign_key_response_ = sign_key_response;
  if (sign_key_response) {
    set_has_sign_key_response();
  } else {
    clear_has_sign_key_response();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ClientMessage_CreateNetwork_AccessRights>() {
  return ::protocol::ClientMessage_CreateNetwork_AccessRights_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ClientMessage_CreateNetwork_Visiblity>() {
  return ::protocol::ClientMessage_CreateNetwork_Visiblity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ClientMessage_CreateNetwork_ParticipationRights>() {
  return ::protocol::ClientMessage_CreateNetwork_ParticipationRights_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ClientMessage_RequestType>() {
  return ::protocol::ClientMessage_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeMessage_ResponseType>() {
  return ::protocol::NodeMessage_ResponseType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sp2p_5fprotocol_2eproto__INCLUDED
